import java.io.*;
import java_cup.runtime.*;
import java.util.*;

parser code {: 
  public Parser(Yylex lex) {
    super(lex);
  }
  public static void main(String[] args)
  {
     try
     {
         Yylex scanner = new Yylex(new BufferedReader(new FileReader(args[0])));
     System.out.println("Start parsing \"" + args[0] + "\"...");
        
        // start parsing
        Parser p = new Parser(scanner);
     System.out.println("Nearing end \"" + args[0] + "\"...");
        Symbol s = p.debug_parse();
     }
     catch(Exception e)
     {
          e.printStackTrace();
     }
  }
  

  LinkedList<Tac> x86_array = new LinkedList<Tac>();
  LinkedList<SimpleBlock> simple_blocks = new LinkedList<SimpleBlock>();
  Env top; 
  int indexSym_counter = 0;
  public String next_env_name(int is_stop)
  {

    if(is_stop==0)
      indexSym_counter++;
    
    return "env<"+indexSym_counter+">";
  }
  public void print_sym_table()
  {

 
    for(Env e=top; e!=null;e=e.get_prev())
    {
        Set set = e.table.entrySet();
        Iterator it = set.iterator();
        while (it.hasNext()) {
          Map.Entry entry = (Map.Entry) it.next();
          System.out.println(entry.getKey() + " : " + ((SymbolTableEntry)entry.getValue()).printOb());
        }
        System.out.println("Changing Tables");
     }   
  
  
  }

  public void print_this_sym_table(Env e)
  {
    Set set = e.table.entrySet();
    Iterator it = set.iterator();
    while (it.hasNext()) {
      Map.Entry entry = (Map.Entry) it.next();
      System.out.println(entry.getKey() + " : " + ((SymbolTableEntry)entry.getValue()).printOb());
    }
  }

  LinkedList<Tac> quad_array = new LinkedList<Tac>();
 
  Map global_registers = new HashMap();
  
  public void gen_registers()
  {
    for(int i=0; i<GoConstants.REGISTERNAMES.size();++i)
    {
      global_registers.put(GoConstants.REGISTERNAMES.get(i), new Register(GoConstants.REGISTERNAMES.get(i)));
    }
  }

  int temp_counter=0;
  public String next_temp(String dataType)
  {
    temp_counter++;
    dataType = get_type_from_symboltable(dataType);
    SymbolTableEntry s = new SymbolTableEntry(dataType, top.global_offset);

    top.global_offset += s.size;

    top.put("t<"+temp_counter+">", s);
    // SymbolTableEntry s =new SymbolTableEntry();

    return "t<"+temp_counter+">";

  }

  int label_counter = 0;
  public String next_label()
  {
    label_counter++;
    return "l<"+label_counter+">";

  }
              
  public void print_qaud_array()
  {
    for(int i=0;i<quad_array.size();++i)
    {
      System.out.print(i+"\t");
      quad_array.get(i).print_tac();
    }
  }
  public void print_next_array(LinkedList<Tac> sent_array)
  {
    for(int i=0;i<sent_array.size();++i)
    {
      sent_array.get(i).print_tac_machine();
    }
  }
  public void print_registers()
  {
    for(int i=0; i<GoConstants.REGISTERNAMES.size();++i)
    {
       ((Register)(global_registers.get(GoConstants.REGISTERNAMES.get(i)))).print_reg();
      // global_registers.put(GoConstants.REGISTERNAMES.get(i), new Register(GoConstants.REGISTERNAMES.get(i)));
    }
  }

  // Tac quad_array[] = new ArrayList<Tac>();

    public String get_type_from_symboltable(String id)
    {

      if ( id.contains(":") == false )
      {
        if ( top.getQuiet(id) != null )
        {
          return top.getQuiet(id).parsedDataType;
        }
        else
          return id;
      }
      List<String> allid = Arrays.asList(id.split(":"));

      List<String> alltype = new ArrayList<String>();

      for ( int i = 0; i < allid.size(); i++ )
      {
        if ( top.getQuiet(allid.get(i)) != null )
        {
          alltype.add(top.getQuiet(allid.get(i)).parsedDataType);
        }
        else
        {
          alltype.add(allid.get(i));
        }
      }


      for ( int i = 0; i < alltype.size()-1; i++ )
      {
        // Type1_Contains_Type2(alltype.get(i), alltype.get(i+1) );
        if ( alltype.get(i).equals(alltype.get(i+1)) == false )
        {
           System.out.println("ERROR: type "+alltype.get(i)+" does not match type "+alltype.get(i+1));
           return null;
        }
        else
        {
           // System.out.println("CORRECT: type "+alltype.get(i)+" does match type "+alltype.get(i+1));
        }
      }

      return alltype.get(0);

    }
    public boolean is_label(String sent)
    { 

      if(sent!=null && (sent.substring(sent.length() - 1)).equals(":") )
        return true;

      return false;
    }
    public boolean is_temp(String sent)
    {
      if(sent!=null && sent.matches("t<([0-9])*>"))
        return true;
      return false;
    }
    public boolean is_sp_labels(String sent, String opr)
    {
      if(sent!=null && opr!=null && opr.equals("goto"))
        return true;
      return false;
    }
    public boolean is_var(String sent, String opr)//opr is required for goto
    {
      // if(sent!=null && !is_label(sent) && !is_temp(sent) && !is_sp_labels(sent,opr) && !GoConstants.checkIfTacReserved(sent) )
      if(sent!=null && sent.matches("#(.*)#"))
        return true;
      return false;
    }
    public String strip_tac_identifier(String id )
    {
        return id.substring(1,id.length() - 1);
    }
    public void next_step()//called at the end of the source file reduction
    {

      for ( Object key : Env.indexSym.keySet() ) 
      {
          System.out.println( (String)key );
          print_this_sym_table((Env)Env.indexSym.get((String)key));
      }

      print_qaud_array();

      LinkedList<String> symbolTables = new LinkedList<String>();
      // LinkedList symbolTables_copy = new LinkedList<String>();

      for(int i=0;i<quad_array.size();++i)
      {
        if(is_label(quad_array.get(i).res))
        {
          symbolTables.addFirst(quad_array.get(i).opr);
          // symbolTables_copy.addFirst(quad_array.get(i).opr);
        }
      }
      
      //Now I have the symbolTbale stack
      // symbolTables_copy = symbolTables;
      //Now I have to start reading from backward
      LinkedList<TacLineInfo> tacline_array = new LinkedList<TacLineInfo>();
      // LinkedList<SimpleBlock> simple_blocks = new LinkedList<SimpleBlock>();
      Env curr_symbol_table;
      curr_symbol_table = (Env)(Env.indexSym.get(symbolTables.pop()));
      for(int i=quad_array.size()-1 ; i>=0 ; i--)
      {
        //if current statement is block start I change the symbol table and also start a new block and append the last one to the linkedlist
        Tac curr_quad_entry = quad_array.get(i);
        if( is_label(curr_quad_entry.res) )
        {
            
          // System.out.println(":::::: i is ::: "+i);
          SimpleBlock new_block = new SimpleBlock(curr_quad_entry.res,curr_symbol_table.get_name(),tacline_array);
          simple_blocks.addFirst(new_block);
          tacline_array = new LinkedList<TacLineInfo>();//this may be costly in future

          if(curr_quad_entry.res.equals("GLOBAL:"))
              break;
          curr_symbol_table = (Env)(Env.indexSym.get(symbolTables.pop()));
        }
        
        else //else we do as given in the book
        {
          // if()
          TacLineInfo new_tac_line = new TacLineInfo();
          if(is_var(curr_quad_entry.res, curr_quad_entry.opr)) //checking is res is really a variable
          {

              //Still have to write code for adding nextuse info
              curr_quad_entry.res = strip_tac_identifier(curr_quad_entry.res);
              // System.out.println()
              Map asli_info = new HashMap();

              SymbolTableEntry var_symboltableentry = curr_symbol_table.get(curr_quad_entry.res);
              asli_info.put("live",var_symboltableentry.live);
              asli_info.put("next_use",var_symboltableentry.next_use);
              new_tac_line.line_info.put(curr_quad_entry.res,asli_info);//==> map of variable_name : asli_info

              var_symboltableentry.live = false;
              var_symboltableentry.next_use = -1;
              curr_symbol_table.update(curr_quad_entry.res,var_symboltableentry);

          }
          if(is_var(curr_quad_entry.op1, curr_quad_entry.opr))
          {
            curr_quad_entry.op1 = strip_tac_identifier(curr_quad_entry.op1);

            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.get(curr_quad_entry.op1);
            asli_info.put("live",var_symboltableentry.live);
            asli_info.put("next_use",var_symboltableentry.next_use);
            new_tac_line.line_info.put(curr_quad_entry.op1,asli_info);//==> map of variable_name : asli_info

            var_symboltableentry.live = true;
            var_symboltableentry.next_use = i;
            curr_symbol_table.update(curr_quad_entry.op1,var_symboltableentry);
          }
          if(is_var(curr_quad_entry.op2, curr_quad_entry.opr))
          {
            curr_quad_entry.op2 = strip_tac_identifier(curr_quad_entry.op2);
            
            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.get(curr_quad_entry.op2);
            asli_info.put("live",var_symboltableentry.live);
            asli_info.put("next_use",var_symboltableentry.next_use);
            new_tac_line.line_info.put(curr_quad_entry.op2,asli_info);//==> map of variable_name : asli_info

            var_symboltableentry.live = true;
            var_symboltableentry.next_use = i;
            curr_symbol_table.update(curr_quad_entry.op2,var_symboltableentry);
          }

          if(is_temp(curr_quad_entry.res)) //checking is res is really a temp
          {

              //Still have to write code for adding nextuse info
              // System.out.println()
              Map asli_info = new HashMap();

              SymbolTableEntry var_symboltableentry = curr_symbol_table.get(curr_quad_entry.res);
              asli_info.put("live",var_symboltableentry.live);
              asli_info.put("next_use",var_symboltableentry.next_use);
              new_tac_line.line_info.put(curr_quad_entry.res,asli_info);//==> map of temp_name : asli_info

              var_symboltableentry.live = false;
              var_symboltableentry.next_use = -1;
              curr_symbol_table.update(curr_quad_entry.res,var_symboltableentry);

          }
          if(is_temp(curr_quad_entry.op1))
          {

            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.get(curr_quad_entry.op1);
            asli_info.put("live",var_symboltableentry.live);
            asli_info.put("next_use",var_symboltableentry.next_use);
            new_tac_line.line_info.put(curr_quad_entry.op1,asli_info);//==> map of temp_name : asli_info

            var_symboltableentry.live = true;
            var_symboltableentry.next_use = i;
            curr_symbol_table.update(curr_quad_entry.op1,var_symboltableentry);
          }
          if(is_temp(curr_quad_entry.op2))
          {
            
            Map asli_info = new HashMap();
            SymbolTableEntry var_symboltableentry = curr_symbol_table.get(curr_quad_entry.op2);
            asli_info.put("live",var_symboltableentry.live);
            asli_info.put("next_use",var_symboltableentry.next_use);
            new_tac_line.line_info.put(curr_quad_entry.op2,asli_info);//==> map of temp_name : asli_info

            var_symboltableentry.live = true;
            var_symboltableentry.next_use = i;
            curr_symbol_table.update(curr_quad_entry.op2,var_symboltableentry);
          }
         /* if(is_label(curr_quad_entry.res) || is_sp_labels(curr_quad_entry.res))
          {
            curr_quad_entry.res = 
          }*/
          new_tac_line.line = curr_quad_entry;
          tacline_array.addFirst(new_tac_line);
        }
      }

      int global_ebp=0,global_esp=0;
      LinkedList<Stack> stack_list = new LinkedList<Stack>();

      //Now i have the simple blocks 
      // LinkedList<Tac> x86_array = new LinkedList<Tac>();
      /*Tac global_data = new Tac();
      global_data.res=".DATA\n";
      // for(Object key : )
       global_data.op1 =""; 

      Env global_table =  (Env)(Env.indexSym.get(simple_blocks.get(0).symbolTable_name));
      for(Object key : global_table.table.keySet())
      {
        if(is_var((String)key))
          global_data.op1 += (String)key+ " DB "+global_table.get((String)key).size+"\n";
        
      }*/

      for(int i=1;i<simple_blocks.size();++i)
      {
          int ebp=0, esp=0;
          int flag=0;
          int sizeblock=0;
          Env symTable;

          symTable=(Env)Env.indexSym.get(simple_blocks.get(i).symbolTable_name);

          SimpleBlock curr_block = simple_blocks.get(i);
          
          LinkedList<TacLineInfo> lines = curr_block.lines;

          Tac new_entry = new Tac();
          
          new_entry.res= curr_block.label_name.replace("<","");
          new_entry.res = new_entry.res.replace(">","");
          
          // new_entry.res = curr_block.label_name;
          x86_array.add(new_entry);

          /********/

          sizeblock = symTable.global_offset;
          if(sizeblock!=symTable.global_offset)
              System.out.println("ERROR: "+sizeblock+" computed != "+symTable.global_offset); 
                
          int ofset=0;
          for(int j=0;j<stack_list.size();j++)
          {
              if(stack_list.get(j).envName.equals(symTable.envName))
              {
                  flag=1;
                  ebp = stack_list.get(j).stack_ebp;
                  esp = stack_list.get(j).stack_esp;

                  break;

              }
              // ofset+=stack_list.get(j).offset;

          }


          if(flag==1)
          {
              // ebp = ofset;
              Tac new_entry5 = new Tac();
              new_entry5.res = "mov";
              new_entry5.op1 = "ebp";
              new_entry5.op2 = "esp";  ////String.valueOf(ebp);
              x86_array.add(new_entry5);
              
              // esp = ofset + stack_list.get(j).offset;
              Tac new_entry2 = new Tac();
              new_entry2.res = "sub";
              new_entry2.op1 = "esp";
              new_entry2.op2 = String.valueOf(esp);
              x86_array.add(new_entry2);
              
          }
          else
          {

              global_ebp = global_esp;
              global_esp = global_esp-sizeblock;

              Stack stack_entry = new Stack(symTable,sizeblock, global_ebp, global_esp);
              stack_list.add(stack_entry);

              Tac new_entry5 = new Tac();
              new_entry5.res = "mov";
              new_entry5.op1 = "ebp";
              new_entry5.op2 =  "esp"; //String.valueOf(global_ebp);
              x86_array.add(new_entry5);

              // esp = esp+sizeblock;
              Tac new_entry2 = new Tac();
              new_entry2.res = "add";
              new_entry2.op1 = "esp";
              new_entry2.op2 = String.valueOf(global_esp-global_ebp);
              x86_array.add(new_entry2);
          }
          /********/







         

          for(int j=0;j<lines.size();++j)
          {
            getx86(lines.get(j),x86_array, (Env)(Env.indexSym.get(curr_block.symbolTable_name)) );
          }

      }
      // print_qaud_array();
      // x86_array.add(global_data);
      print_next_array(x86_array);
     /* LinkedList<Tac> next_array = new LinkedList<Tac>();

      for(int i=0;i<quad_array.size();++i)
      {
          Tac next_entry =  new Tac();
          if(i==0 && is_label(quad_array.get(i).res)==false )
          {
            next_entry.res = "<BLOCK START>";
            next_array.add(next_entry);
            next_array.add(quad_array.get(i));
          }
          else if(is_label(quad_array.get(i).res)==true)
          {
            next_entry.res = "<BLOCK START>";
            next_array.add(next_entry);
            next_array.add(quad_array.get(i));

          }
          else if(quad_array.get(i).opr!=null && quad_array.get(i).opr.equals("goto"))
          {
            next_array.add(quad_array.get(i));
            next_entry.res = "<BLOCK START>";
            next_array.add(next_entry);
          }
          else
            next_array.add(quad_array.get(i));
            
          //Debating whether to use own data structure to propagate next use info. or
          // revive symbol table.
      }*/
      // print_next_array(next_array);
      System.out.println("***************");
      for(int i=0;i<simple_blocks.size();++i)
      {
        // System.out.println("\n********"++"*******\n");
        simple_blocks.get(i).print_block();

      }

      

    }
    public void getx86(TacLineInfo tac_line_info, LinkedList<Tac> x86_array,Env symbolTable)
    {
      Tac line = tac_line_info.line;
      // Map registers = getReg(tac_line_info);
      Register res_register, op1_register, op2_register;
      

            System.out.print("LINE RECIEVED ");
            // line.print_tac();
            System.out.print(line.res+" : "+line.op1+" : "+line.opr+" : "+line.op2);


      Tac new_entry = new Tac();
      
      if ( line.opr != null )
        {
          if ( line.opr == "=" )
          { 
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array);
            SymbolTableEntry s = symbolTable.get(line.res);

            new_entry.res = "mov";
            
            if(op1_register == null) //we have i= const
            {
              res_register = getReg(line.res,0,symbolTable,line,x86_array);
              

              new_entry.op1 = res_register.name;
              new_entry.op2 = line.op1;
              int size = symbolTable.get(line.res).get_default_size();
              String type="ERROR";
              if(size==1)
                type = "BYTE PTR";
              else if(size==2)
                type="WORD PTR";
              else if(size==4)
                type="DWORD PTR";
              else
                System.out.println("ERROR : WORD SIZE "+size+" NOT SUPPORTED");
              new_entry.res = "mov";//+type;
            }
            else
            {
              res_register = op1_register;
              new_entry.op1 = res_register.name;
              new_entry.op2 = op1_register.name;
              

              s.fix_reg_addrDesc(res_register.name, global_registers, line.res);


              Map reg_map = new HashMap();//variable-> symboltable
              reg_map.put(line.op1,symbolTable);
              op1_register.add_to_regdesc(reg_map);

              SymbolTableEntry s2= new SymbolTableEntry();
              s2 = symbolTable.get(line.op1);

              s2.add_to_addrdesc(op1_register.name,line.op1);
              symbolTable.update(line.op1, s2);

              symbolTable.get(line.op1).print_addrDesc(line.op1);
            }

            
            s.add_to_addrdesc(res_register.name,line.res);
            symbolTable.update(line.res, s);


            // if(symbolTable.get(line.res).addressDescriptor.indexOf(res_register.name)!=-1)
              // symbolTable.get(line.res).addressDescriptor.addFirst(res_register.name);

            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            x86_array.add(new_entry);
            print_registers();

            symbolTable.get(line.res).print_addrDesc(line.res);

            //Handled only reg->reg or const->reg
          }
            /*  else if (  line.opr == "goto" )//|| res == "push" || res == "call" || res == "import" || res == "package" )
              {
              // do nothing
              new_entry.res = "goto";
              new_entry.op1 = line.res;
              x86_array.add(new_entry);
            }*/
          else if ( line.opr == "+" )
          {
            //Tac new_entry = new Tac();
            
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+s.offset+"]";

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "add";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);

          } 
          else if ( line.opr == "-" )
          {
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+s.offset+"]";

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "sub";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in sub, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);
          }
          else if ( line.opr == "*" )
          {
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+s.offset+"]";

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "imul";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in imul, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);  
          }
          else if ( line.opr == "/" || line.opr == "%" )
          {
              

            //edx : line.op1
            //empty register and
            x86_array.addAll(((Register)global_registers.get("edx")).spill(""));
            x86_array.addAll(((Register)global_registers.get("eax")).spill(""));

            // op1_register = getReg(line.op1,1,symbolTable,line,x86_array);
            String op1_reg_name = symbolTable.get(line.op1).get_prev_register();
            if(op1_reg_name!=null)
            {
              Tac new_entry3 = new Tac();
              new_entry3.res = "mov";
              new_entry3.op1 = "edx";
              new_entry3.op2 = op1_reg_name;
              x86_array.add(new_entry3);
            }
            else
            {
              Tac new_entry3 = new Tac();
              new_entry3.res = "mov";
              new_entry3.op1 = "edx";
              new_entry3.op2 = "[ebp-"+symbolTable.get(line.op1).offset+"]";

              x86_array.add(new_entry3); 
            }


            Tac new_entry2 = new Tac();
            new_entry2.res="idiv";
            String op2_reg_name = symbolTable.get(line.op2).get_prev_register();
            if(op2_reg_name!=null)
            {
              new_entry2.op1 = op2_reg_name;
            }
            else
            {
              new_entry2.op1 = "[ebp-"+symbolTable.get(line.op2).offset+"]";
            }
            x86_array.add(new_entry2);


            new_entry.res ="mov";

            String res_reg_name = symbolTable.get(line.res).get_prev_register();
            if(res_reg_name==null)
            {
              new_entry.op1 = "[ebp-"+symbolTable.get(line.res).offset+"]";
              SymbolTableEntry s = symbolTable.get(line.res);
              s.add_to_addrdesc("[ebp-"+symbolTable.get(line.res).offset+"]",line.res);
              symbolTable.update(line.res,s);
              // s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            }
            else
            {
              new_entry.op1 = res_reg_name;
            }

            if(line.opr=="%")
            {
              //ans in edx
              new_entry.op2="edx";
            }
            else
            {
              //ans in eax
              new_entry.op2="eax";
            }
            x86_array.add(new_entry);

          }
          else if ( line.opr == "&" || line.opr == "&&" )
          {
            //Tac new_entry = new Tac();
             
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+s.offset+"]";

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "and";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);    
          }
          else if ( line.opr == "|" || line.opr == "||" )
          {
            //Tac new_entry = new Tac();
           new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+s.offset+"]";

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "or";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);    
          }
          else if ( line.opr == "^" )
          {
            //Tac new_entry = new Tac();
            new_entry.res = "mov";

            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op2 = op1_register.name;


            res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            String res_mem_loc = "[ebp-"+s.offset+"]";

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);


            new_entry.op1 = res_register.name;

            x86_array.add(new_entry);
            

            // ADD STARTS
            Tac new_entry2 = new Tac();
            new_entry2.res = "xor";

            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry2.op2 = op2_register.name;

            // if op2 got the same register as res, then add op2 to memory of res
            // else add op2 to register of res

            if ( res_register.name.equals(op2_register.name) == true )
            {
              System.out.println("WARNING: "+" in add, op2 takes same register as res!");
              new_entry2.op1 = res_mem_loc;
            }
            else
            {
              new_entry2.op1 = res_register.name;
            }
            
            x86_array.add(new_entry2);       
          }
          else if ( line.opr == ">>" )
          {
            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            x86_array.addAll(((Register)global_registers.get("eax")).spill(""));

            Tac new_entry3 = new Tac();
            String op1_reg_name = symbolTable.get(line.op1).get_prev_register();
            if(op1_reg_name!=null)
            {
              new_entry3.op2 = op1_reg_name;
            }
            else
            {
              new_entry3.op2 = "[ebp-"+symbolTable.get(line.op1).offset+"]";
            }
            
            res_register = (Register)global_registers.get("eax"); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.res);
                   
            s2.add_to_addrdesc(res_register.name,line.res);
            symbolTable.update(line.res, s2);
            
            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map2);

            
            new_entry3.res="mov";
            new_entry3.op1=res_register.name;
            x86_array.add(new_entry3);
            

            //force op2 to go into cl
            String op2_reg_name = symbolTable.get(line.op2).get_prev_register();
            if(op2_reg_name!=null)
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = op2_reg_name;
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2);
            }
            else
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = "[ebp-"+symbolTable.get(line.op2).offset+"]";
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2); 
            }

            new_entry.res="shr";
            new_entry.op1=res_register.name;
            new_entry.op2="cl";
            x86_array.add(new_entry);


          }
          else if ( line.opr == "<<" )
          {
            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            x86_array.addAll(((Register)global_registers.get("eax")).spill(""));

            Tac new_entry3 = new Tac();
            String op1_reg_name = symbolTable.get(line.op1).get_prev_register();
            if(op1_reg_name!=null)
            {
              new_entry3.op2 = op1_reg_name;
            }
            else
            {
              new_entry3.op2 = "[ebp-"+symbolTable.get(line.op1).offset+"]";
            }
            
            res_register = (Register)global_registers.get("eax"); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.res);
                   
            s2.add_to_addrdesc(res_register.name,line.res);
            symbolTable.update(line.res, s2);
            
            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map2);

            
            new_entry3.res="mov";
            new_entry3.op1=res_register.name;
            x86_array.add(new_entry3);
            

            //force op2 to go into cl
            String op2_reg_name = symbolTable.get(line.op2).get_prev_register();
            if(op2_reg_name!=null)
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = op2_reg_name;
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2);
            }
            else
            {
              Tac new_entry2 = new Tac();
              new_entry2.op2 = "[ebp-"+symbolTable.get(line.op2).offset+"]";
              new_entry2.res="mov";
              new_entry2.op1="cl";
              x86_array.add(new_entry2); 
            }

            new_entry.res="shl";
            new_entry.op1=res_register.name;
            new_entry.op2="cl";
            x86_array.add(new_entry);  
          }
          else if ( line.opr == "<" )
          {
            new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+s2.offset+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setb";
            x86_array.add(new_entry2);

          }
          else if ( line.opr == "<=" )
          {
            //Tac new_entry = new Tac();
              new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+s2.offset+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setbe";
            x86_array.add(new_entry2);
          }
          else if ( line.opr == ">" )
          {
            //Tac new_entry = new Tac();
              new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+s2.offset+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "seta";
            x86_array.add(new_entry2);
          }
          else if ( line.opr == ">=" )
          {
            //Tac new_entry = new Tac();
             new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+s2.offset+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setae";
            x86_array.add(new_entry2);      
          }
          else if ( line.opr == "==" )
          {
            new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+s2.offset+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "sete";
            x86_array.add(new_entry2);
          }
          else if ( line.opr == "!" )
          {
            //Tac new_entry = new Tac();
            x86_array.add(new_entry);
            new_entry.res = "not";
            new_entry.op1 = line.op1;        
          }
          else if ( line.opr == "!=" )
          {
            //Tac new_entry = new Tac();
              new_entry.res = "cmp";
            op1_register = getReg(line.op1,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s2 = symbolTable.get(line.op1);

            s2.add_to_addrdesc(op1_register.name,line.op1);
            symbolTable.update(line.op1, s2);


            Map reg_map2 = new HashMap();//variable-> symboltable
            reg_map2.put(line.op1,symbolTable);
            op1_register.add_to_regdesc(reg_map2);

            new_entry.op1 = op1_register.name;


            op2_register = getReg(line.op2,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
            SymbolTableEntry s3 = symbolTable.get(line.op2);

            s3.add_to_addrdesc(op2_register.name,line.op2);
            symbolTable.update(line.op2, s3);


            Map reg_map3 = new HashMap();//variable-> symboltable
            reg_map3.put(line.op2,symbolTable);
            op2_register.add_to_regdesc(reg_map3);

            new_entry.op2 = op2_register.name;


            if (op1_register.name.equals(op2_register.name) == true)
            {
              // op1 replaced by op2, so op1 has latest copy in its memory
              new_entry.op1 = "[ebp-"+s2.offset+"]";
            }

            x86_array.add(new_entry);

            // SETB STARTS
            Tac new_entry2 = new Tac();

            x86_array.addAll(((Register)global_registers.get("ecx")).spill(""));
            
            res_register = (Register)global_registers.get("ecx");

            // res_register = getReg(line.res,0,symbolTable,line,x86_array); // 0 is mode (for LHS)
            SymbolTableEntry s = symbolTable.get(line.res);

            s.fix_reg_addrDesc(res_register.name, global_registers, line.res);
            s.add_to_addrdesc(res_register.name,line.res);

            symbolTable.update(line.res, s);


            Map reg_map = new HashMap();//variable-> symboltable
            reg_map.put(line.res,symbolTable);
            res_register.add_to_regdesc(reg_map);
            
            new_entry2.op1 = "cl";
            new_entry2.res = "setne";
            x86_array.add(new_entry2);      
          }
          else if ( line.opr == "&^" )
          {
            //Tac new_entry = new Tac();
            x86_array.add(new_entry);
            new_entry.res = "mov";
            new_entry.op1 = line.res;
            new_entry.op2 = line.op1;
            
            Tac new_entry2 = new Tac();
            x86_array.add(new_entry2);
            new_entry2.res = "and";
            new_entry2.op1 = line.res;
            new_entry2.op2 = line.op2; 

            Tac new_entry3 = new Tac();
            x86_array.add(new_entry3);
            new_entry3.res = "not";
            new_entry3.op1 = new_entry2.op1;
          }
          else if ( line.opr == "goto" )
          {
            if ( line.op1 == null && line.op2 == null )  
            {
               // System.out.print("LINE RECIEVED &&&&&&&&&");
              // line.print_tac();
              // System.out.print(line.res+" : "+line.op1+" : "+line.opr+" : "+line.op2);
              //Tac new_entry = new Tac();
              new_entry.res = "jmp";
              new_entry.op1= line.res.replace("<","");
              new_entry.op1 = new_entry.op1.replace(">","");
              x86_array.add(new_entry);
            }
            else
            {
              //Tac new_entry = new Tac();
              new_entry.res = "cmp";
              // new_entry.op1 = line.op1
              String[] parts = line.op1.split("false ");
              String cond_var = parts[1];
              // new_entry.op1 = 

              op1_register = getReg(cond_var,1,symbolTable,line,x86_array); // 1 is mode (for RHS)
              SymbolTableEntry s2 = symbolTable.get(cond_var);

              s2.add_to_addrdesc(op1_register.name,cond_var);
              symbolTable.update(cond_var, s2);


              Map reg_map2 = new HashMap();//variable-> symboltable
              reg_map2.put(cond_var,symbolTable);
              op1_register.add_to_regdesc(reg_map2);

              new_entry.op2 = op1_register.name;

              new_entry.op1 =op1_register.name;
              new_entry.op2 = "0";   
              x86_array.add(new_entry);
              
              Tac new_entry2 = new Tac();
              new_entry2.res = "jle";
              new_entry2.op1= line.res.replace("<","");
              new_entry2.op1 = new_entry.op2.replace(">","");
              // new_entry2.op1 = line.res;
             
              x86_array.add(new_entry2);
            }
          }
        }
        else
        {
          System.out.println("ERROR : Label sent here");
        }
    }
    public Register getReg(String variable, int mode,Env symbolTable,Tac line,LinkedList<Tac> x86_array)//mode =0 for left, mode=1 for right
    {
      if(mode==0)
      {
        SymbolTableEntry s = symbolTable.get(variable);
        if( s.addressDescriptor.size()!=0 )
        {
          String reg = s.get_prev_register();
          if(reg!=null)
          {
            Register retrieved_register = (Register)(global_registers.get(reg));
            if(retrieved_register.if_var_in_reg(variable)==true)
            {
              //now we spill back other variables as we are changing reg value.
              x86_array.addAll(retrieved_register.spill(variable));
              return retrieved_register;
            }
            
            else
            {
                System.out.println("ERROR: Mismatch in addressDescriptor and regDescriptor");
            }
          }
          else//need to kick out or find an empty register
          {
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  if(temp_reg.is_descriptor_empty()==true)
                    return temp_reg;
              }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING MODE 0");
              //Oh no! someone is gonna lose registers
              //finding least spill cost among registers
              int min_cost=1000000;
              int cur_cost=1000000;
              String min_key="";
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  // if(temp_reg.is_descriptor_empty()==true)
                    // return temp_reg;
                  cur_cost=temp_reg.spill_cost(line);
                  if(cur_cost<min_cost)
                  {
                    min_key = (String)key;
                    min_cost = cur_cost; 
                  }
              }
              Register selectedReg = (Register) global_registers.get(min_key);
              x86_array.addAll(selectedReg.spill(variable));
              return selectedReg;
          }
        }
        else
        {
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                if(temp_reg.is_descriptor_empty()==true)
                  return temp_reg;
            }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING NASTY MODE 0");

            //Oh no! someone is gonna lose registers
            //finding least spill cost among registers
            int min_cost=1000000;
            int cur_cost=1000000;
            String min_key="";
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                // if(temp_reg.is_descriptor_empty()==true)
                  // return temp_reg;
                cur_cost=temp_reg.spill_cost(line);
                System.out.println("Searching space for "+variable+ "  "+"REG: "+temp_reg.name+" spill cost "+cur_cost);
                if(cur_cost<min_cost)
                {
                  min_key = (String)key;
                  min_cost = cur_cost; 
                }
            }
            Register selectedReg = (Register)(global_registers.get(min_key));
            x86_array.addAll(selectedReg.spill(variable));
            return selectedReg;
        }
      }
      else if(mode==1)
      {
        SymbolTableEntry s = symbolTable.get(variable);
        if(s==null)
          return null;//for constants
        
        if( s.addressDescriptor.size()!=0 )
        {
          String reg = s.get_prev_register();
          if(reg!=null)
          {
            Register retrieved_register = (Register)(global_registers.get(reg));
            if(retrieved_register.if_var_in_reg(variable)==true)
              return retrieved_register;
            else
            {
                System.out.println("ERROR: Mismatch in addressDescriptor and regDescriptor");
            }
          }
          else//need to kick out or find an empty register
          {
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  if(temp_reg.is_descriptor_empty()==true)
                  { 
                      if(s.is_empty_addrDesc()==true)
                      {
                        return temp_reg;
                      }
                      Tac new_entry = new Tac();
                      new_entry.res="mov";
                      new_entry.op1=temp_reg.name;
                      new_entry.op2=s.addressDescriptor.getFirst();
                      x86_array.add(new_entry);
                      return temp_reg;
                  }
              }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING  MODE 1");

              //Oh no! someone is gonna lose registers
              //finding least spill cost among registers
              int min_cost=1000000;
              int cur_cost=1000000;
              String min_key="";
              for ( Object key : global_registers.keySet() ) 
              {
                  Register temp_reg =  (Register)(global_registers.get((String)key));
                  // if(temp_reg.is_descriptor_empty()==true)
                    // return temp_reg;
                  cur_cost=temp_reg.spill_cost(line);
                  System.out.println("[mode 1] Searching space for "+variable+ "  "+"REG: "+temp_reg.name+" spill cost "+cur_cost);
                  if(cur_cost<min_cost)
                  {
                    min_key = (String)key;
                    min_cost = cur_cost; 
                  }
              }
              Register selectedReg = (Register) global_registers.get(min_key);
              x86_array.addAll(selectedReg.spill(variable));
              
              if(s.is_empty_addrDesc()==true)
              {
                return selectedReg;
              }
              Tac new_entry = new Tac();
              new_entry.res="mov";
              new_entry.op1=selectedReg.name;
              new_entry.op2=s.addressDescriptor.getFirst();
              x86_array.add(new_entry);
              return selectedReg;
          }
        }
        else
        {
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                if(temp_reg.is_descriptor_empty()==true)
                  return temp_reg;
            }
              System.out.println("KICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCKKKKKKKKKKING NASTY MODE 1");

            //Oh no! someone is gonna lose registers
            //finding least spill cost among registers
            int min_cost=1000000;
            int cur_cost=1000000;
            String min_key="";
            for ( Object key : global_registers.keySet() ) 
            {
                Register temp_reg =  (Register)(global_registers.get((String)key));
                // if(temp_reg.is_descriptor_empty()==true)
                  // return temp_reg;
                cur_cost=temp_reg.spill_cost(line);
                if(cur_cost<min_cost)
                {
                  min_key = (String)key;
                  min_cost = cur_cost; 
                }
            }
            Register selectedReg = (Register)(global_registers.get(min_key));
            x86_array.addAll(selectedReg.spill(variable));
            return selectedReg;
        }
      }
      else
      {
        System.out.println("ERROR: ARE YAAR mode is <> 0 or 1 !");
      }
      return null;
    }


    public void stack_func()
    {
      int global_ebp=0,global_esp=0;
      LinkedList<Stack> stack_list = new LinkedList<Stack>();

      for(int i=0;i<simple_blocks.size();++i)
      {
        int ebp=0, esp=0;
        int flag=0;
        int sizeblock=0;
        Env symTable;

        symTable=(Env)Env.indexSym.get(simple_blocks.get(i).symbolTable_name);

        //LinkedList<String> var_stack = new LinkedList<String>();
        /*for(int j=0;j<(((simple_blocks.get(i)).lines).get(j).line_info).size();j++)
        {
            //((simple_blocks.lines).line_info).get(j)

            
            //simple_blocks.lines)

            for ( String key : ((simple_blocks.lines).line_info).keySet() ) 
            {
                
                
                symTable=(Env)Env.indexSym.get(simple_blocks.symbolTable_name);

                SymbolTableEntry s;
                s=symTable.get(key);

                sizeblock+=s.size;            
            }
        }*/
        sizeblock = symTable.global_offset;
        if(sizeblock!=symTable.global_offset)
            System.out.println("ERROR: "+sizeblock+" computed != "+symTable.global_offset); 
              
        int ofset=0;
        for(int j=0;j<stack_list.size();j++)
        {
            if(stack_list.get(j).envName.equals(symTable.envName))
            {
                flag=1;
                ebp = stack_list.get(j).stack_ebp;
                esp = stack_list.get(j).stack_esp;

                break;

            }
            // ofset+=stack_list.get(j).offset;

        }


        if(flag==1)
        {
            // ebp = ofset;
            Tac new_entry = new Tac();
            new_entry.res = "mov";
            new_entry.op1 = "ebp";
            new_entry.op2 = String.valueOf(ebp);
            x86_array.add(new_entry);
            
            // esp = ofset + stack_list.get(j).offset;
            Tac new_entry2 = new Tac();
            new_entry2.res = "mov";
            new_entry2.op1 = "esp";
            new_entry2.op2 = String.valueOf(esp);
            x86_array.add(new_entry2);
            
        }
        else
        {

            global_ebp = global_esp;
            global_esp = global_esp-sizeblock;

            Stack stack_entry = new Stack(symTable,sizeblock, global_ebp, global_esp);
            stack_list.add(stack_entry);

            Tac new_entry = new Tac();
            new_entry.res = "mov";
            new_entry.op1 = "ebp";
            new_entry.op2 = String.valueOf(global_ebp);
            x86_array.add(new_entry);

            // esp = esp+sizeblock;
            Tac new_entry2 = new Tac();
            new_entry2.res = "mov";
            new_entry2.op1 = "esp";
            new_entry2.op2 = String.valueOf(global_esp);
            x86_array.add(new_entry2);
        }

      }

    }
:};


// ############################################### IDENTIFIERS #######################################################

terminal String identifier;
// ############################################### LITERALS  TERMINALS#######################################################

terminal String int_lit, imaginary_lit, float_lit, rune_lit, string_lit;

// ############################################### LITERALS  NON-TERMINALS#######################################################


// ############################################### KEYWORD TERMINALS #######################################################
terminal breakd, defaultd, funcd, interfaced, select, cased, defer, go, map, struct, chan, elsed, gotod;
terminal packaged, switchd, constd, fallthrough, ifd, range, type, continued, ford, importd, returnd, var;

// ############################################### OPERATORS TERMINALS #######################################################

terminal String or_op, and_op; //specially created 

terminal String equal_equal_op, not_equal_op, less_op, less_equal_op, greater_op, greater_equal_op;
terminal String plus_op, minus_op, pipe_op, pow_op;

terminal String star_op, div_op, mod_op, left_shift_op, right_shift_op, amp_op, amp_pow_op;
terminal String not_op, chan_op;

// ############################################ DELIMITERS AND SPECIAL TOKEN TERMINALS #####################################

terminal open_brac, close_brac, open_square_brac, close_square_brac, open_curly_brac, close_curly_brac;
terminal inc_op, short_ass, comma, semicolon, dec_op;
terminal tri_dot, dot, colon;
terminal equal;

// ############################################### OPERATORS NONTERMINALS #######################################################

non terminal String binary_op;
non terminal String unary_op;
non terminal String rel_op, add_op, mul_op; 
non terminal String assign_op;

// ############################################### PREDEFINED TYPES TERMINALS #######################################################

// ############################################### NON-TERMINALS #######################################################

non terminal GoType Type;
non terminal GoTypeName TypeName;
non terminal GoTypeLit TypeLit;
non terminal QualifiedIdent;
non terminal GoArrayType ArrayType;
non terminal StructType;
non terminal GoPointerType PointerType;
non terminal GoSignature FunctionType;
non terminal InterfaceType, SliceType, MapType, ChannelType;
// non terminal GoExpr ArrayLength;
non terminal Integer ArrayLength;
non terminal GoExpr Expression; // ElementType, 
non terminal FieldDecl, AnonymousField;// Tag;
non terminal LinkedList<String> IdentifierList;
non terminal GoSignature Signature;
non terminal  Result;
non terminal LinkedList<GoParameterDecl> Parameters;
non terminal LinkedList<GoParameterDecl> ParameterList;
non terminal GoParameterDecl ParameterDecl;
non terminal MethodSpec, MethodName, InterfaceTypeName;
non terminal KeyType;


non terminal StatementList, Statement;
non terminal Block;
non terminal IfBlock, ForBlock;


non terminal Declaration, ConstDecl, TypeDecl, VarDecl, TopLevelDecl, FunctionDecl, MethodDecl;
non terminal ConstSpec;
non terminal LinkedList<GoExpr> ExpressionList;
non terminal TypeSpec;
non terminal VarSpec;
non terminal ShortVarDecl;
non terminal FunctionName;
non terminal GoSignature Function;
non terminal FunctionBody; // Signature
non terminal Receiver;


non terminal GoOperand Operand;
non terminal OperandName, MethodExpr;
non terminal Map BasicLit;
non terminal CompositeLit, FunctionLit, Literal; // Expression
non terminal PackageName; // QualifiedIdent
non terminal LiteralType;
non terminal GoLiteralValue LiteralValue;
non terminal GoElementList ElementList;
non terminal GoElement Element;
non terminal Key;
non terminal GoValue Value;
non terminal FieldName, ElementIndex;
non terminal GoPrimaryExpr PrimaryExpr;   // added 
non terminal Conversion;
non terminal GoSelector Selector;
non terminal GoIndex Index;
non terminal Slice, TypeAssertion, Arguments;
non terminal ReceiverType;
non terminal GoUnaryExpr UnaryExpr;

non terminal LabeledStmt;
non terminal LabeledForStmt;
non terminal SimpleStmt, GoStmt, ReturnStmt, BreakStmt, ContinueStmt; // Declaration
non terminal  GotoStmt, FallthroughStmt,  SwitchStmt, SelectStmt , DeferStmt; // Block
non terminal GoForStmt ForStmt;
non terminal GoIfStmt IfStmt;
non terminal Map Cheez;
non terminal Map Cheez2;

non terminal EmptyStmt, ExpressionStmt, SendStmt, IncDecStmt, Assignment; // ShortVarDecl

non terminal Label; // LabeledStmt

non terminal Channel;

non terminal ExprSwitchStmt, TypeSwitchStmt, ExprCaseClause, ExprSwitchCase; // StatementList
non terminal TypeSwitchGuard, TypeSwitchCase, TypeList, TypeCaseClause;

non terminal Condition;
non terminal Map ForClause;
non terminal RangeClause, InitStmt, PostStmt;

non terminal CommClause, CommCase, RecvStmt, RecvExpr;

non terminal SourceFile, PackageClause, ImportDecl;
non terminal LinkedList<String> ImportSpec;
non terminal ImportPath; // TopLevelDecl, PackageName

// ############################################### UNNECESSARY NON-TERMINALS #######################################################

// TYPE RULES UNNECESSARY NON TERMINALS
non terminal StructType_unnecessary_1, FieldDecl_unnecessary_1, FieldDecl_unnecessary_2, AnonymousField_unnecessary_1;
non terminal Signature_unnecessary_1, Parameters_unnecessary_1, Parameters_unnecessary_2;
non terminal LinkedList<GoParameterDecl>() ParameterList_unnecessary_1;
non terminal ParameterDecl_unnecessary_1, ParameterDecl_unnecessary_2;
non terminal InterfaceType_unnecessary_1, ChannelType_unnecessary_1;

// BLOCK RULES UNNECESSARY NON TERMINALS
non terminal StatementList_unnecessary_1;

// DECLARATION AND SCOPE RULES UNNECESSARY NON TERMINALS
non terminal ConstDecl_unnecessary_1, ConstDecl_unnecessary_2, ConstSpec_unnecessary_1, ConstSpec_unnecessary_2;
non terminal LinkedList<String> IdentifierList_unnecessary_1;
non terminal LinkedList<GoExpr> ExpressionList_unnecessary_1;
non terminal TypeDecl_unnecessary_1, TypeDecl_unnecessary_2;
non terminal VarDecl_unnecessary_1, VarDecl_unnecessary_2;
non terminal LinkedList<GoExpr> VarSpec_unnecessary_1;
non terminal Map VarSpec_unnecessary_2;
non terminal GoSignature FunctionDecl_unnecessary_1;
non terminal MethodDecl_unnecessary_1;

// EXPRESSION RULES UNNECESSARY NON TERMINALS
non terminal LiteralValue_unnecessary_1;
non terminal GoElementList LiteralValue_unnecessary_2;
non terminal Element_unnecessary_1;
non terminal LinkedList<GoElement> ElementList_unnecessary_1;
non terminal Slice_unnecessary_1, Slice_unnecessary_2, Slice_unnecessary_3;
non terminal Arguments_unnecessary_1, Arguments_unnecessary_2, Arguments_unnecessary_3, Arguments_unnecessary_4, Arguments_unnecessary_5;

// OPERATORS RULES UNNECESSARY NON TERMINALS
non terminal Conversion_unnecessary_1;

// STATEMENT RULES UNNECESSARY NON TERMINALS
non terminal String IncDecStmt_unnecessary_1;
non terminal String assign_op_unnecessary_1;
non terminal IfStmt_unnecessary_1, IfStmt_unnecessary_2, IfStmt_unnecessary_3;
non terminal ExprSwitchStmt_unnecessary_1, ExprSwitchStmt_unnecessary_2, ExprSwitchStmt_unnecessary_3;
non terminal TypeCaseClause_unnecessary_1, TypeSwitchStmt_unnecessary_1, TypeSwitchStmt_unnecessary_2;
non terminal TypeSwitchGuard_unnecessary_1, TypeSwitchGuard_unnecessary_2, TypeList_unnecessary_1, TypeList_unnecessary_2;
non terminal CommClause_unnecessary_1;
non terminal Map ForStmt_unnecessary_1;
non terminal Map ForStmt_unnecessary_2;
non terminal Map ForStmt_unnecessary_3;
non terminal InitStmt_unnecessary_1;
non terminal Map Condition_unnecessary_1;
non terminal PostStmt_unnecessary_1;
non terminal RangeClause_unnecessary_1, RangeClause_unnecessary_2, CommClause_unneccesary_1, CommCase_unncessary_1, RecvStmt_unncessary_1;
non terminal ReturnStmt_unnecessary_1, Label_unnecessary_1;

// PACKAGES RULES UNNECESSARY NON TERMINALS
non terminal SourceFile_unnecessary_1, SourceFile_unnecessary_2;
non terminal LinkedList<String> ImportDecl_unnecessary_1;
non terminal LinkedList<String> ImportDecl_unnecessary_2;
non terminal ImportSpec_unnecessary_1;



non terminal QualifiedIdent_dash, IdentifierList_unnecessary_1_dash, SourceFile_unnecessary_1_dash, SourceFile_unnecessary_2_dash;
non terminal ParameterList_unnecessary_1_dash, Operand_unnecessary_1_dash, ExpressionList_unnecessary_1_dash;

non terminal GoExprUnn Expression_unneccessary_1_dash;
non terminal Map SimpleStmt_unnecessary_1;

non terminal String B, C;

non terminal GoFunc_call Func_call;
non terminal Func_call_ass;

non terminal String ForClause_Unneccesary;
non terminal WhileStmt;

// ############################################### PRECEDENCE & ASSOCIATIVITY #######################################################

precedence left or_op;
precedence left and_op;
precedence left equal_equal_op, not_equal_op, less_op, less_equal_op, greater_op, greater_equal_op;
precedence left plus_op, minus_op, pipe_op, pow_op;
precedence left star_op, div_op, mod_op, left_shift_op, right_shift_op, amp_op, amp_pow_op;
precedence nonassoc equal;

// ############################################### START RULE #######################################################

start with SourceFile;

// ############################################### TYPE RULES #######################################################

Type      ::= TypeName:t {: RESULT = new GoType(t); :} | TypeLit:tl {:RESULT = new GoType(tl);:} | open_brac Type:t close_brac {: RESULT = t; :};
TypeName  ::= B:b 
              {: 
                RESULT = new GoTypeName(b); 
              :} 
              | C:c 
              {: 
                RESULT = new GoTypeName(c); 
              :};

B ::= C:c dot identifier:i {: RESULT = c+"."+i; :};
C ::= identifier:i {: RESULT = i; :};
TypeLit   ::=     ArrayType:at {: RESULT = new GoTypeLit(at); :}
                | PointerType:pt {: RESULT = new GoTypeLit(pt); :}
                | FunctionType:ft {: RESULT = new GoTypeLit(ft); :};     // | SliceType ; //  StructType 

ArrayType   ::= open_square_brac   ArrayLength:al close_square_brac Type:t {: RESULT = new GoArrayType(al, t); :};
// ArrayLength ::= Expression:ex {: RESULT = ex; :};
ArrayLength ::= int_lit:i {: RESULT =  new Integer(Integer.parseInt( i )); :};

PointerType ::= star_op Type:t {: RESULT = new GoPointerType(t); :}; //DOUBT

// Func_call ::= TypeName:tn  open_brac close_brac {: RESULT = new GoFunc_call( tn );:} 
//             | TypeName:tn open_brac ExpressionList:el  close_brac {: RESULT = new GoFunc_call( tn, el );:};


Func_call ::= TypeName:tn  open_brac close_brac 
              {: 
                if(top.get("_"+tn.typeName)!=null)
                {
                  Tac new_entry = new Tac();
                  new_entry.res = "call";
                  new_entry.op1 = "_"+tn.typeName;
                  quad_array.add(new_entry);

                      

                }
                else
                {
                  System.out.println("ERROR: Function not defined");
                } 
                RESULT = new GoFunc_call( tn );
              :} 
              | TypeName:tn open_brac ExpressionList:el  close_brac 
              {: 
                 if(top.get("_"+tn.typeName)==null)
                    System.out.println("ERROR: Function "+tn.typeName+" not defined");
                  else
                  {

                      String[] allowed_expected_types = new String[]{"bool","byte","complex64","complex128","float32","float64","int","int8","int16","int32","int64","rune","string","uint","uint8","uint16","uint32","uint64","uintpt"};
                      // System.out.println("GOOD NEWs:  FUnction call working");
                      // LinkedList<GoExpr> expr = (LinkedList<GoExpr>)s1.get("func_ass");
                      // expr.addFirst(e);
                      String func_name = "_"+tn.typeName;
                      SymbolTableEntry func_entry = top.get(func_name);
                      // if(func_entry !=null )
                      // {
                      GoSignature func_sig = (GoSignature)(func_entry.dataType);
                      // if(func_sig.obj instanceof LinkedList)//multiple return types
                      // {
                      int k=0;
                      LinkedList<GoParameterDecl> parameters =func_sig.parameters;
                      int expected_number = 0;
                      for(int q=0;q<parameters.size();++q)
                      {
                        if(parameters.get(q).identifierList!=null)
                            expected_number+=parameters.get(q).identifierList.size();
                        else
                          expected_number++;
                      }
                      if(expected_number!=el.size())
                        System.out.println("ERROR: Unequal number of parameters."+expected_number+" != "+el.size());
                      
                      // System.out.println("PARAMETER SIZE:"+parameters.size());
                      for(int i=0;i<parameters.size();++i)
                      {
                        // System.out.println("Checking param types");
                        GoParameterDecl params= parameters.get(i);
                        if(params.identifierList!=null)
                        {
                          for(int j=0;j<params.identifierList.size();++j)
                          {
                            if(k==el.size())
                            {
                              System.out.println("ERROR: Too many variables expected from functions");
                              break;
                            }
                            SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);

                            String expr_type = el.get(k).get_type();
                            if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                              expr_type = top.get(expr_type).parsedDataType;
                            if(!expr_type.equals(s100.parsedDataType))
                            {
                             System.out.println("expected : "+expr_type +" Found : "+s100.parsedDataType);
                             System.out.println("ERROR: Type Mismatch in func call");
                            }
                                                           
                            k++;

                          }

                        }
                        else
                        {
                          if(k==el.size())
                          {
                            System.out.println("ERROR: Too many variables expected from functions");
                            break;
                          }
                          SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);
                          String expr_type = el.get(k).get_type();
                          if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                            expr_type = top.get(expr_type).parsedDataType;
                          if(!expr_type.equals(s100.parsedDataType))
                          {
                           System.out.println("expected :"+ expr_type +" Found : "+s100.parsedDataType);
                           System.out.println("ERROR: Type Mismatch in calling function");
                          }
                         
                          Tac new_entry2 =new Tac();
                        
                          k++;

                        }
                      }
                      // }

                    




                      for(int i=0;i<el.size();++i)
                      {
                          Tac new_entry = new Tac();
                          new_entry.res = "push";
                          new_entry.opr =  quad_array.get(el.get(i).index).res;
                          quad_array.add(new_entry);
                      /**/
                      }
                      Tac new_entry2 = new Tac();
                      new_entry2.res = "call";
                      new_entry2.op1 = "_"+tn.typeName;
                      quad_array.add(new_entry2);
                  }
                
                

                  RESULT = new GoFunc_call( tn, el );
              :};



FunctionType   ::= funcd Signature:s {: RESULT = s;:};
Signature      ::= Parameters:p1 Parameters:p2 {: RESULT = new GoSignature(p1,p2); :}
                  | Parameters:p1 Type:t {: RESULT = new GoSignature(p1,t); :}
                  | Parameters:p1 {: RESULT = new GoSignature(p1); :};

Parameters     ::=
 // open_brac ParameterList:pl comma close_brac {: RESULT= pl; :}
                   open_brac ParameterList:pl close_brac {: RESULT= pl; :}
                  | open_brac close_brac {: RESULT= new LinkedList<GoParameterDecl>(); :};

ParameterList  ::= ParameterDecl:pd ParameterList_unnecessary_1:pl {: pl.addFirst(pd); RESULT = pl; :};
ParameterList_unnecessary_1 ::= ParameterList_unnecessary_1:pl1 comma ParameterDecl:pd  {: pl1.add(pd); RESULT = pl1; :}
                                | {: RESULT = new LinkedList<GoParameterDecl>(); :};

ParameterDecl  ::=    IdentifierList:i1 Type:t {: RESULT = new GoParameterDecl(i1, t); :}
                    | Type:t {: RESULT = new GoParameterDecl(t); :}; // | IdentifierList tri_dot Type | tri_dot Type 

// ############################################### BLOCK RULES #######################################################

Block  ::=  
          open_curly_brac 
          {: if(top!=null) 
              {
                top = new Env(top,next_env_name(0));

                Tac new_entry = new Tac();
                new_entry.res = next_label()+":";
                new_entry.opr = top.get_name();
                quad_array.add(new_entry);

                // System.out.println("NEW BLOCK TABLE"); 
              } 
          :}
          StatementList close_curly_brac 
          {: 
            // print_sym_table();
            if(top.get_prev()!=null)
              top = top.get_prev();

            Tac new_entry = new Tac();
            new_entry.res = next_label()+":";
            new_entry.opr = top.get_name();
            quad_array.add(new_entry);
                
          :} ;

StatementList ::= StatementList_unnecessary_1 ;
StatementList_unnecessary_1 ::= StatementList_unnecessary_1 Statement semicolon | ;

// ############################################### DECLARATION AND SCOPE RULES #######################################################

TopLevelDecl  ::= FunctionDecl | Declaration  ; //handled at 16:16 28/3

// FunctionDecl ::= funcd identifier FunctionDecl_unnecessary_1;

FunctionDecl ::= funcd identifier:i 
                {:
                  /**/
                  //problem how to know whether prototype or real function, so using the standard method
                  Tac new_entry = new Tac();
                  new_entry.res = "_"+i+":";
                  new_entry.opr = next_env_name(0);

                  quad_array.add(new_entry);

                  SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,i);
                  top.put("func<>",s);//for manipulating the label created above

                 s = new SymbolTableEntry();
                  top.put("_"+i,s); //prototype also gets to go to the symbol table but it's label 3AC is removed 
                :} 
                FunctionDecl_unnecessary_1:fun
                {:

                  SymbolTableEntry s = new SymbolTableEntry(fun,true,0);
                  // System.out.println("WHILE UPDATING  PARAMETERS ARE:"+((GoSignature)(s.dataType)).parameters.size());
                  top.update("_"+i,s);

                :};//All the return types are already stored in the symbol table for this


// FunctionDecl_unnecessary_1 ::=  Function | Signature;


FunctionDecl_unnecessary_1 ::=    Function:fsig 
                                  {:/**/
                                    Tac new_entry = new Tac();
                                    new_entry.res = "ret";
                                    quad_array.add(new_entry);
                                    // System.out.println("WHILE UPDATING  REICEVED PARAMETERS ARE2:"+fsig.parameters.size());

                                    top.removeFromCurrent("func<>");
                                    RESULT = fsig;
                                  :}
                                | Signature:si
                                  {:  /**/
                                     SymbolTableEntry s = top.get("func<>");
                                     quad_array.remove(s.size);
                                     top.removeFromCurrent("func<>");
                                     // s = new SymbolTableEntry ()
                                      // System.out.println("WHILE UPDATING  REICEVED PARAMETERS ARE1:"+si.parameters.size());

                                     RESULT = si;
                                     //removed label for function protoype 
                                 :};


Function     ::=  Signature:si 
                  {:
                    top = new Env(top,true,next_env_name(1)); 
                    
                    // System.out.println("WHILE UPDATING  REICEVED PARAMETERS ARE3:"+String.valueOf (si.parameters.size()));
                    // System.out.println("NEW TABLE IN FUnction");
                    SymbolTableEntry s;
                    for(int i=0;i<si.parameters.size();++i)
                    {
                      // System.out.println("Hello bellow2");
                      GoParameterDecl paramDecl =  si.parameters.get(i);
                      for (int j=0;j<paramDecl.identifierList.size() ; ++j) 
                      {
                        s = new SymbolTableEntry( paramDecl.type.obj,false,top.global_offset );  
                        top.global_offset+=s.size;
                        top.put( paramDecl.identifierList.get(j),s );  
                      }
                      
                    }
                    if(si.obj instanceof GoType)
                    {
                      // System.out.println("Hello bellow1");
                      GoType return_type = (GoType)si.obj;
                      // s = new SymbolTableEntry( return_type.obj,false );
                      s = new SymbolTableEntry( return_type.obj,false,top.global_offset );
                      top.global_offset+=s.size;

                      top.put("return[0]",s );  
                    }
                    else if (si.obj instanceof LinkedList)
                    {
                      // SymbolTableEntry s[si.obj.size()];
                      // System.out.println("Hello bellow");
                      LinkedList<GoParameterDecl> temp_obj = (LinkedList<GoParameterDecl>)si.obj;
                      int k=0;
                      for(int i=0;i<temp_obj.size();++i)
                      {
                          // s = new SymbolTableEntry( temp_obj.get(i).type.obj,false );
                      /**/    
                        if(temp_obj.get(i).identifierList!=null)
                        {
                          for(int j=0;j<temp_obj.get(i).identifierList.size();++j)
                          {
                            s = new SymbolTableEntry(temp_obj.get(i).type.obj,false,top.global_offset );
                            top.put("return["+k+"]",s );
                            k++;
                            s = new SymbolTableEntry(temp_obj.get(i).type.obj,false,top.global_offset);
                            top.global_offset+=s.size;
                            top.put(temp_obj.get(i).identifierList.get(j),s);
                          }
                        }
                        else
                        {
                          s = new SymbolTableEntry(temp_obj.get(i).type.obj,false,top.global_offset );
                          // top.global_offset+=s.size;
                          top.put("return["+k+"]",s );

                          k++;
                        }
                          //TODO-DONE add support for identifierlist in symboltable
                      }

                    }
                    RESULT =si;
                  :}
                  FunctionBody:fb 
                  {: 
                      // print_sym_table();
                      if(si.obj!=null  )
                      {
                          if(si.obj instanceof LinkedList)
                          {
                            if(((LinkedList<GoParameterDecl>)si.obj).size()!=0 && top.getQuiet("@return@")==null)
                              System.out.println("ERROR: Missing return statement in function");
                          }
                          else
                          {
                           if(top.getQuiet("@return@")==null)
                              System.out.println("ERROR: Missing return statement in function");
                          }

                      }
                     /* if(top.getQuiet("@return@")==null)
                      {
                        //must be void function else error
                        if(si.obj ==null)
                        {
                          System.out.println("ERROR: Missing return statement in function");
                        }
                      }*/
                      if(top.get_prev()!=null)
                        top = top.get_prev(); 
                  :};


FunctionBody ::= open_curly_brac StatementList close_curly_brac;

Declaration   ::= ConstDecl | VarDecl; //  TypeDecl |
ConstDecl      ::= constd ConstDecl_unnecessary_2;
ConstDecl_unnecessary_1 ::= ConstDecl_unnecessary_1 ConstSpec semicolon | ;
ConstDecl_unnecessary_2 ::= ConstSpec | open_brac ConstDecl_unnecessary_1 close_brac;
/*ConstSpec      ::= IdentifierList ConstSpec_unnecessary_2; //*******DOUBT "="
ConstSpec_unnecessary_1 ::=  Type:t {: RESULT = t:} 
                            | ;
ConstSpec_unnecessary_2 ::= ConstSpec_unnecessary_1:cu equal ExpressionList:el 
                            {: 
                                Map a = new HashMap(); 
                                a.put("Type", cu); 
                                a.put("ExpressionList", el);
                                RESULT = a;
                              // RESULT = new Map :} 
                            
                            | ;*/
ConstSpec      ::= IdentifierList:il Type:t equal ExpressionList: el 
                  {:
                      // System.out.println("Adding constant to symbol table");
                      // LinkedList<GoExpr> expList = (LinkedList<GoExpr>).get("ExpressionList");
                      SymbolTableEntry s;
                      boolean flag = true;
                      if ( il.size() != el.size() )
                      {
                          if( el.size() > 0 )
                          {
                            if ( el.size() > il.size() )
                            {
                              System.out.println("ERROR: extra expression in const declaration");
                            }
                            else
                            {
                              System.out.println("ERROR: missing value in const declaration");
                            }
                          }
                          flag = false;
                      }
                      // System.out.println("Size of id is "+il.size()+" size of el is "+el.size());
                      String dataType_from_id = t.get_type();

                      dataType_from_id = get_type_from_symboltable(dataType_from_id);

                      for ( int i = 0; i < il.size(); i++ ) 
                      {
                          if ( flag == true )
                          {
                              // typechecking
                              // System.out.println("Inside flag true");
                              
                              String dataType_from_exp = el.get(i).get_type(); // now this type can be either a real datatype like int32, int etc or can be the name of the identifier 
                              // so if it is the name of an identifier, we will look at its symbol table entry and derive its parsedDataType from there
                              
                              dataType_from_exp = get_type_from_symboltable(dataType_from_exp);

                              SymbolTableEntry sym = top.get(dataType_from_exp);
                              if ( sym != null )  // dataType_from_exp is identifier
                              {
                                dataType_from_exp = sym.parsedDataType;
                                // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                              }

                              // System.out.println("vu is "+dataType_from_vu+" exp is "+dataType_from_exp);


                              if ( dataType_from_id.equals(dataType_from_exp) == false )
                              {
                                if ( el.get(i).get_identifier() != null )
                                  System.out.println("ERROR: cannot use "+el.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_id+" in assignment 1");
                                else
                                  System.out.println("ERROR: cannot use "+"(type "+dataType_from_exp+") as type "+dataType_from_id+" in assignment 2");
                              }
                              else
                              {
                                // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                              }

                              s = new SymbolTableEntry(  t.obj, true, top.global_offset);    // expressionlist also needs to be handled
                              Tac new_entry = new Tac();
                                  // new_entry.res =  "Mem<"+ top.global_offset +">";
                                  new_entry.res = "#"+il.get(i)+"#";

                                  new_entry.opr = "=";
                                  new_entry.op1= quad_array.get(el.get(i).index).res;

                                  quad_array.add(new_entry);
                              top.global_offset+=s.size;
                          }
                          else
                          {
                              // System.out.println("Inside flag false");  
                              // we will never reach here as it is outside grammar rules

                              s = new SymbolTableEntry( t.obj,true, top.global_offset);
                              top.global_offset+=s.size;
                          }

                          // according to grammar, we cannot have const arrays const are like
                          // #define of C. so they cannot have arrays, maps, slices etc.

                          //for entering array 
                          if( t.obj instanceof GoTypeLit 
                              && ((GoTypeLit)t.obj).obj instanceof GoArrayType)
                          {
                            System.out.println("ERROR: arrays not allowed in const");
                            GoArrayType arr = ((GoArrayType)((GoTypeLit)t.obj).obj) ;
                            int array_size = ((Integer)(arr.arrayLength)).intValue();
                            top.global_offset-=s.size;//above statement added size of one var already to offset
                            s.size=array_size*s.size;
                            top.global_offset+=s.size;
                          }
                          top.put(il.get(i), s); 
                           
                      }
                  :}; //*******DOUBT "="

// IdentifierList ::=  identifier  IdentifierList_unnecessary_1;
// IdentifierList_unnecessary_1 ::= comma IdentifierList | ;

IdentifierList ::= identifier:i IdentifierList_unnecessary_1:i1 {: i1.addFirst(i); RESULT = i1; :};
IdentifierList_unnecessary_1 ::= comma identifier:i IdentifierList_unnecessary_1:i1  {: i1.addFirst(i); RESULT = i1; :} 
                                 | {: RESULT = new LinkedList<String>(); :};


// IdentifierList ::= C:i 
//                     {: LinkedList<String> a = new LinkedList<String>(); a.add(i); RESULT = a;:}
//                   | IdentifierList:i1 comma IdentifierList:i2
//                   {:
//                       for ( int x = 0; x < i2.size(); x++ )
//                       {
//                         i1.add(i2.get(x));
//                       }
//                       RESULT = i1;
//                   :}
//                   ;

/*ExpressionList ::= Expression:ex {:  LinkedList<GoExpr> el = new LinkedList<GoExpr>(); el.add(ex); RESULT = el; :}
                  | Expression:ex comma ExpressionList:el 
                    {: 
                        el.addFirst(ex); 
                        RESULT = el; 
                   :};*/

ExpressionList ::= Expression:ex ExpressionList_unnecessary_1:eu {: eu.addFirst(ex); RESULT = eu; :};
ExpressionList_unnecessary_1 ::= ExpressionList_unnecessary_1:eu comma Expression:ex {: eu.add(ex); RESULT = eu; :} 
                                | {: RESULT = new LinkedList<GoExpr>(); :};

VarDecl     ::= var VarDecl_unnecessary_2;
VarDecl_unnecessary_1 ::= VarDecl_unnecessary_1 VarSpec semicolon | ;
VarDecl_unnecessary_2 ::= VarSpec | open_brac VarDecl_unnecessary_1 close_brac;
VarSpec     ::= IdentifierList:i1 VarSpec_unnecessary_2:vu 
                {: 
                    LinkedList<GoExpr> expList = (LinkedList<GoExpr>)vu.get("ExpressionList");
                    SymbolTableEntry s;
                    boolean flag = true;
                    if ( i1.size() != expList.size() )
                    {
                        if(expList.size()>0)
                        {
                          if ( expList.size() > i1.size() )
                          {
                            System.out.println("ERROR: extra expression in var declaration");
                          }
                          else
                          {
                            System.out.println("ERROR: missing expression in var declaration");
                          }
                        }
                        flag = false;
                    }

                    for ( int i = 0; i < i1.size(); i++ ) 
                    {
                        if ( flag == true ) //a ,b,c int=2,2,3;
                        {
                          if(vu.get("Type")!=null)
                          {
                                // for type checking, we need to see that dataType of vu.get("Type") is same as explist.get(i).get_type()
                                
                                String dataType_from_vu = ( (GoType)vu.get("Type") ).get_type();

                                dataType_from_vu = get_type_from_symboltable(dataType_from_vu);

                                String dataType_from_exp = expList.get(i).get_type(); // now this type can be either a real datatype like int32, int etc or can be the name of the identifier 
                                // so if it is the name of an identifier, we will look at its symbol table entry and derive its parsedDataType from there
                                
                                dataType_from_exp = get_type_from_symboltable(dataType_from_exp);

                                SymbolTableEntry sym = top.getQuiet(dataType_from_exp);
                                if ( sym != null )  // dataType_from_exp is identifier
                                {
                                  dataType_from_exp = sym.parsedDataType;
                                  // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                                }

                                // System.out.println("vu is "+dataType_from_vu+" exp is "+dataType_from_exp);

                                if ( dataType_from_vu.equals(dataType_from_exp) == false )
                                {
                                  if ( expList.get(i).get_identifier() != null )
                                    System.out.println("ERROR: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment 3");
                                  else
                                    System.out.println("ERROR: cannot use "+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment 4");
                                }
                                else
                                {
                                  // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                                }

                                // System.out.println("i wrr= "+i); 
                                s = new SymbolTableEntry(  ((GoType) vu.get("Type")).obj,false,top.global_offset);    // expressionlist also needs to be handled
                                Tac new_entry = new Tac();
                                    // new_entry.res =  "Mem<"+ top.global_offset +">";
                                    new_entry.res = "#"+i1.get(i)+"#";
                                    new_entry.opr = "=";
                                    new_entry.op1= quad_array.get(expList.get(i).index).res;
                                top.global_offset+=s.size;
                                quad_array.add(new_entry);
                          }
                          else // array type of form: var a = [2]int{1,2}
                          {
                                GoUnaryExpr first_unary = expList.get(expList.size()-i-1).unaryExpr;
                                GoTypeName temp_name = new GoTypeName(first_unary.get_type());

                                // temp_name = get_type_from_symboltable(temp_name);

                                GoOperand temp_operand = (GoOperand)((GoPrimaryExpr)(first_unary.obj)).obj1;
                                GoArrayType arraytype = (GoArrayType)(temp_operand.obj);

                                String dataType_from_array = arraytype.get_type();

                                dataType_from_array = get_type_from_symboltable(dataType_from_array);

                                //FOR 1D
                                int arr_length = arraytype.get_array_length();


                                s = new SymbolTableEntry( temp_name,false, top.global_offset); //MINING TYPE_NAME FROM Expr List for array type
                                s.isArray = true;

                                LinkedList<GoElement> temp_element_list = temp_operand.litVal.eleList.eleList;
                                 int qindex = -1;
                                for(int k = 0; k < temp_element_list.size(); ++k )
                                {
                                    qindex = ((GoExpr)(temp_element_list.get(k).val.obj)).index;
                                    // quad_array.get(qindex).res; // actaul value of arr[k] !

                                    GoExpr expr = ((GoExpr)(temp_element_list.get(k).val.obj));
                                    String dataType_from_exp = expr.get_type(); // now this type can be either a real datatype like int32, int etc or can be the name of the identifier 
                                    // so if it is the name of an identifier, we will look at its symbol table entry and derive its parsedDataType from there
                                    
                                    dataType_from_exp = get_type_from_symboltable(dataType_from_exp);

                                    SymbolTableEntry sym = top.getQuiet(dataType_from_exp);
                                    if ( sym != null )  // dataType_from_exp is identifier
                                    {
                                      dataType_from_exp = sym.parsedDataType;
                                      // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                                    }



                                    if ( dataType_from_array.equals(dataType_from_exp) == false )
                                    {
                                      System.out.println("ERROR: cannot use "+expr.get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_array+" in assignment 5");
                                    }

                                    // for typechecking, we have to see that type of expr is same as type of array

                                    Tac new_entry = new Tac();
                                        // new_entry.res =  "Mem<"+ top.global_offset +">";
                                        new_entry.res = "#"+i1.get(i)+"#";
                                        new_entry.opr = "=";
                                        new_entry.op1= quad_array.get(qindex).res;
                                    top.global_offset+=s.size;
                                    quad_array.add(new_entry);
                                }

                                if ( temp_element_list.size() > arr_length )  // like var a = [2]int{1,2,3} ie more things inside array than allowed
                                {
                                  System.out.println("ERROR: "+"array index "+arr_length+" out of bounds [0:"+arr_length+"]");
                                }

                                if ( arr_length > temp_element_list.size() )  // have to initialize the remaining values with default values
                                {
                                  for(int k = 0; k < arr_length-temp_element_list.size(); ++k )
                                  {
                                    Tac new_entry = new Tac();
                                        // new_entry.res = "Mem<"+ top.global_offset +">";
                                        new_entry.res = "#"+i1.get(i)+"#";
                                        new_entry.opr = "=";
                                        new_entry.op1= s.get_default_value(s.parsedDataType);

                                    top.global_offset+=s.size;
                                    quad_array.add(new_entry);
                                  }
                                }
                                s.size=arr_length*s.size;

                                // break;
                          }

                        // top.put(i1.get(i), s); // commented since already doing it below

                        }
                        else //int uninitialized
                        {
                            // no need of typechecking here as we are only giving it default values
                            s = new SymbolTableEntry(((GoType) vu.get("Type")).obj,false, top.global_offset);
                            //TODO handle 3ac of default initialisation
                            // System.out.println("Creating "+s.offset);
                            Tac new_entry = new Tac();
                                // new_entry.res =  "Mem<"+ top.global_offset +">";
                                new_entry.res = "#"+i1.get(i)+"#";
                                new_entry.opr = "=";
                                new_entry.op1= s.get_default_value(s.parsedDataType);

                            top.global_offset+=s.size;

                            quad_array.add(new_entry);
                            // System.out.println("PUURITN "+s.offset);
                         // System.out.println("Getting "+top.get(i1.get(i)).offset);
                        }

                        if(s==null) System.out.println("ERROR: null SymbolTableEntry");
                        if(i1.get(i) == null)
                           System.out.println("ERROR: null IdentifierList");
                        
                        if(vu.get("Type") == null)
                        {
                          //YEY!!Already DOne for initialised array above
                        }
                        //for  uninitialized arrays a[16]
                        else if( ((GoType)vu.get("Type")).obj instanceof GoTypeLit && ((GoTypeLit)((GoType)vu.get("Type")).obj).obj instanceof GoArrayType)
                        {

                            // no need of type checking as we are filling default values ourselves
                            GoArrayType arr =  (GoArrayType)(((GoTypeLit)((GoType)vu.get("Type")).obj).obj);
                            int array_size = ((Integer)arr.arrayLength).intValue();
                            // top.global_offset-=s.size;//above statement added size of one var already to offset
                            // System.out.println("ARRAY SIZE "+array_size);
                            // System.out.println("S SIZE "+s.size);
                            for(int q=1;q<array_size;++q)
                            {
                                Tac new_entry = new Tac();
                                // new_entry.res = "Mem<"+ top.global_offset +">";
                                new_entry.res = "#"+i1.get(i)+"#";
                                new_entry.opr = "=";
                                new_entry.op1= s.get_default_value(s.parsedDataType);

                                top.global_offset+=s.size;
                                quad_array.add(new_entry);
                            }
                            s.size=array_size*s.size;
                            s.isArray = true;
                            // top.global_offset+=s.size;

                        }
                    top.put(i1.get(i), s);
                    }

                :}; //************DOUBT "="


                
VarSpec_unnecessary_1 ::= equal ExpressionList:el {: RESULT = el; :}
                          | {: RESULT = new LinkedList<GoExpr>(); :} ;
VarSpec_unnecessary_2 ::= Type:t  
                          VarSpec_unnecessary_1:vu 
                          {: 
                                Map a = new HashMap(); 
                                a.put("Type", t); 
                                a.put("ExpressionList", vu);
                                RESULT = a; 
                          :}
                          | equal ExpressionList:vu
                          {:
                                Map a = new HashMap(); 
                                // a.put("Type", t); 
                                a.put("ExpressionList", vu);
                                RESULT = a; 

                          :}
                          ; // maybe used for shorthand, NOPE Exactly used for arrays

// ############################################### EXPRESSION RULES #######################################################

Operand     ::= BasicLit:bl 
                {:    
                  RESULT = new GoOperand((String)(bl.get("value")), (String)(bl.get("Type")));  
                :} 
                | ArrayType:at LiteralValue:lv 
                {: 
                  RESULT = new GoOperand(at, lv); 
                :}
                // | TypeName:tn LiteralValue:lv {: RESULT = new GoOperand(tn, lv); :}
                | TypeName:tn 
                {: 
                  RESULT = new GoOperand(tn); // used both for operands (identifiers) and real typenames like int32 etc
                :}
                | open_brac Expression:ex close_brac 
                {: 
                  RESULT = new GoOperand(ex); 
                :};

BasicLit    ::=   int_lit:il 
                    {:          
                        Map a = new HashMap(); 
                        a.put("Type", "int"); 
                        a.put("value", il);
                        RESULT = a;  :}
                | float_lit:fl 
                    {:          
                        Map a = new HashMap(); 
                        a.put("Type", "float"); 
                        a.put("value", fl);
                        RESULT = a;  :} 
                | imaginary_lit:ml 
                    {:          
                        Map a = new HashMap(); 
                        a.put("Type", "imaginary"); 
                        a.put("value", ml);
                        RESULT = a;  :} 
                | rune_lit:rl 
                    {:          
                        Map a = new HashMap(); 
                        a.put("Type", "rune"); 
                        a.put("value", rl);
                        RESULT = a;  :} 
                | string_lit:sl 
                  {:          
                      Map a = new HashMap(); 
                      a.put("Type", "string"); 
                      a.put("value", sl);
                      RESULT = a;  
                  :} ;

LiteralValue  ::= open_curly_brac LiteralValue_unnecessary_2:ll {: RESULT = new GoLiteralValue(ll); :} close_curly_brac;
LiteralValue_unnecessary_1 ::= comma | ;    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
LiteralValue_unnecessary_2 ::= ElementList:el {: RESULT = el; :} LiteralValue_unnecessary_1  | ;


ElementList   ::= Element:e ElementList_unnecessary_1:e1 {: e1.addFirst(e); RESULT = new GoElementList(e1); :} ;
ElementList_unnecessary_1 ::= ElementList_unnecessary_1:e1 comma Element:e {: e1.add(e); RESULT = e1; :}
                                | {: RESULT = new LinkedList<GoElement>(); :} ;

Element       ::= /*identifier:i colon Value:v {: RESULT = new GoElement(v, i); :}
                  | Expression:ex colon Value:v  {: RESULT = new GoElement(v, ex); :}
                  |*/ Value:v {: RESULT = new GoElement(v); :};

Value         ::= Expression:ex {: RESULT = new GoValue(ex); :}
                  | LiteralValue:lv {: RESULT = new GoValue(lv); :};

PrimaryExpr ::=     Operand:od {: RESULT = new GoPrimaryExpr(od); :}
                // |   PrimaryExpr:px Selector:sl {: RESULT = new GoPrimaryExpr(px, sl); :}  //for structures
                |   PrimaryExpr:px Index:in 
                {: 
                  // we have to see that px formed here does support indexing, ie it is array type, slice type etc
                  String id = px.get_identifier();
                  SymbolTableEntry s = top.get(id);
                  String dataType = s.parsedDataType;
                  // System.out.println("array of type "+s.parsedDataType);
                  // System.out.println("size of array is "+s.size+" while default size is "+s.get_default_size());

                  if ( s.isArray == false )  
                  {
                    System.out.println("ERROR: "+"invalid operation on "+id +": (type "+s.parsedDataType+" does not support indexing)");
                  }
                  RESULT = new GoPrimaryExpr(px, in); 
                :};


// Selector       ::= dot identifier:i {: RESULT = new GoSelector(i); :};


Index          ::= open_square_brac Expression:ex close_square_brac 
                  {: 
                    // this expression should be non negative integer at run time 
                    // and integer at compile time

                    String dataType_from_exp = ex.get_type(); 

                    dataType_from_exp = get_type_from_symboltable(dataType_from_exp);
                    
                    SymbolTableEntry sym = top.getQuiet(dataType_from_exp);
                    if ( sym != null )  // dataType_from_exp is identifier
                    {
                      dataType_from_exp = sym.parsedDataType;
                      // System.out.println("dataType_from_exp changed to "+dataType_from_exp);
                    }

                    if ( GoConstants.checkIfIntegralNumeric(dataType_from_exp) == false )
                    {
                      System.out.println("ERROR: "+"non-integer array index ");
                    }

                    RESULT = new GoIndex(ex); 
                  :};

// ############################################### OPERATORS RULES #######################################################

Expression ::= UnaryExpr:ux
                {:
                  RESULT = new GoExpr(ux,ux.index);
                :}
                | Expression:ux or_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "||";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux and_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "&&";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ex plus_op:bo Expression:ux 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "+";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux minus_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "-";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux pipe_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "|";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux pow_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "^";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux equal_equal_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "==";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux not_equal_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "!=";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux greater_equal_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = ">=";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux greater_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = ">";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux less_equal_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "<=";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux less_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "<";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux star_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "*";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux div_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "/";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux mod_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "%";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux left_shift_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "<<";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                | Expression:ux right_shift_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = ">>";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}
                /*| Expression:ux amp_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp()+"@@@";
                    new_entry.opr = "&";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                 RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :}*/
                | Expression:ux amp_pow_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp(ex.get_type())+"";
                    new_entry.opr = "&^";
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                    RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :};



/*
Expression ::= UnaryExpr:ux
                {:
                  RESULT = new GoExpr(ux,ux.index);
                :}
                | UnaryExpr:ux binary_op:bo Expression:ex 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp()+"";
                    new_entry.opr = bo;
                    new_entry.op1= unexpr.res;
                    new_entry.op2= expr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                 RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :};

*/

/*Expression ::= UnaryExpr:ux Expression_unneccessary_1_dash:eu 
              {: 

                Tac last= quad_array.get(quad_array.size()-1);
                if(last.res==null)
                {
                  int index = ux.index;
                  Tac ux_entry = quad_array.get(index);
                  if(ux_entry.res!=null)
                  {
                    last.push_empty(ux_entry.res);
                    last.res = next_temp();
                  }
                  else
                  {
                    if ( ux_entry.get_filled() != null )
                    {
                        last.push_empty(ux_entry.get_filled());
                        last.res = next_temp();
                    }
                    else
                    {
                      System.out.println("ERROR: UnaryExprError4");
                    }
                  }

                }
                else
                {
                  System.out.println("ERROR: UnaryExprError3");
                }
                GoExpr ex = new GoExpr(eu, ux);
                ex.gen(); 

                print_qaud_array();
                RESULT = ex; 
              :};

Expression_unneccessary_1_dash ::=      binary_op:bp UnaryExpr:ux
                                        {:
                                          
                                            Tac last= quad_array.get(quad_array.size()-1);
                                            if( last.res == null) //PrimaryExpr
                                            {
                                               // if(last.op1 ==null)
                                                  // last.op2=
                                              last.opr= bp;

                                            }
                                            else//unary_op Unaryexpr
                                            {
                                              Tac new_entry =new Tac();

                                              if(new_entry.push_empty(last.res)!=0)
                                              {
                                                System.out.println("ERROR: UnaryExprError2");
                                              }
                                              new_entry.opr = bp;
                                              quad_array.add(new_entry);
                                            }
                                          
                                          
                                        :} Expression_unneccessary_1_dash:eu {: RESULT = new GoExprUnn(ux, bp, eu); :}
                                    | {: RESULT = new GoExprUnn(); :};*/

UnaryExpr  ::=     PrimaryExpr:px 
                  {:  
                    if(px.obj2!=null && px.obj2 instanceof GoIndex)
                    {

                      //case of array reference
                      //Assuming expression has been evaluated
                      /*Tac last= quad_array.get(quad_array.size()-1);
                      Tac new_entry;
                      new_entry.op2 = last.res;
                      // String temp_var_name =  next_temp();

                      new_entry.opr="array";*/
                      // new_entry.res= SymbolTablle lookup for a[temp_var_name]
                      String index_res = quad_array.get(((GoIndex)(px.obj2)).expr.index).res;

                      String table_entry_name = px.get_identifier();
                      // System.out.println("@#@#@<InArray>Looking up the tan :"+table_entry_name);
                      
                      Tac new_entry =new Tac();
                      SymbolTableEntry s;
                      s = top.get(table_entry_name);
                      // new_entry.op1= "Mem<"+s.offset+"+"+s.get_default_size()+"*"+index_res+">";
                      new_entry.op1 = "#"+table_entry_name+"#";
                      new_entry.res = next_temp(s.parsedDataType);
                      new_entry.opr = "=";

                      quad_array.add(new_entry);
                    
                      RESULT = new GoUnaryExpr(px,quad_array.size()-1);

                    }
                    else if(px.obj1 instanceof GoOperand )
                    {
                        GoOperand temp= ((GoOperand)px.obj1);
                        if( temp.obj instanceof  String )  //BAsicLit
                        {

                          Tac new_entry =new Tac();
                          new_entry.op1= (String)temp.obj;
                          new_entry.res = next_temp(temp.type);
                          new_entry.opr="=";/***/
                          quad_array.add(new_entry);

                         /* Tac last;
                          if(quad_array.size()==0)
                          {
                            last =new Tac();
                            last.res="sdff";
                          }
                          else
                            last= quad_array.get(quad_array.size()-1);

                          if( last.res ==null )
                          {
                              if(last.push_empty((String)temp.obj)!=0)
                              {
                                System.out.println("ERROR: both operands filled but why is result empty ? ");
                              }
                              if(last.opr!=null)
                                last.res = next_temp();
                          }
                          else if(last.res!=null)
                          {
                            Tac new_entry =new Tac();
                            new_entry.op2= (String)temp.obj;
                            quad_array.add(new_entry);
                          }*/
                         
                          RESULT = new GoUnaryExpr(px,quad_array.size()-1); 
                        }
                        else if (temp.obj instanceof GoTypeName)
                        {
                          
                          String name = ((GoTypeName)temp.obj).typeName;
                          // System.out.println("@#@#@Looking up the tan :"+name);
                          Tac new_entry =new Tac();
                          SymbolTableEntry s;
                          // s = top.get(name);
                          // new_entry.op1= "Mem<"+s.offset+">";
                          new_entry.op1 = "#"+name+"#";
                          new_entry.res = next_temp(temp.type);
                          new_entry.opr= "=";/***/
                          quad_array.add(new_entry);
                        
                          RESULT = new GoUnaryExpr(px,quad_array.size()-1); 

                        }
                        else
                        {
                          // System.out.println("ERROR: Case not handled in PrimaryExpr:Operand");
                        }
                    }
                    else
                    {
                      // System.out.println("ERROR: Case not handled in PrimaryExpr");
                    }
                    // else if( px.obj2)
                    RESULT = new GoUnaryExpr(px,quad_array.size()-1); 
                  :}
                  | unary_op:up UnaryExpr:ux 
                  {: 
                    Tac last= quad_array.get(ux.index);
                    if( last.res==null ) //PrimaryExpr
                    {
                        //comes form primaryexpr
                        last.opr = up;
                        last.res = next_temp(ux.get_type());
                        // quad_array.add(last);
                        RESULT = new GoUnaryExpr(ux, up,ux.index); 
                      
                    }
                    else //UnaryExpr
                    {
                      Tac new_entry = new Tac();
                      new_entry.op2 = last.res;
                      new_entry.opr = up;
                      new_entry.res = next_temp(ux.get_type());
                      quad_array.add(new_entry);
                      RESULT = new GoUnaryExpr(ux, up,quad_array.size()-1); 
                    }
                    
                  :};

binary_op  ::= or_op:o  {: RESULT = "||"; :}
              | and_op:a   {: RESULT = "&&"; :}
              | rel_op:r   {: RESULT = r; :}
              | add_op:a   {: RESULT = a; :}
              | mul_op:m   {: RESULT = m; :};

rel_op     ::= equal_equal_op:ee {: RESULT = "=="; :}
              | not_equal_op:ne {: RESULT = "!="; :} 
              | less_op:lo {: RESULT = "<"; :}
              | less_equal_op:le {: RESULT = "<="; :} 
              | greater_op:go {: RESULT = ">"; :}
              | greater_equal_op:ge {: RESULT = ">="; :}; // "==" | "!=" | "<" | "<=" | ">" | ">="

add_op     ::= plus_op:p {: RESULT = "+"; :}
              | minus_op:m {: RESULT = "-"; :} 
              | pipe_op:p {: RESULT = "|"; :} 
              | pow_op:p {: RESULT = "^"; :}; // "+" | "-" | "|" | "^"

mul_op     ::= star_op:s {: RESULT = "*"; :} 
              | div_op:d {: RESULT = "/"; :} 
              | mod_op:m {: RESULT = "%"; :} 
              | left_shift_op:ls {: RESULT = "<<"; :} 
              | right_shift_op:rs {: RESULT = ">>"; :} 
              | amp_op:a {: RESULT = "&"; :} 
              | amp_pow_op:a {: RESULT = "&^"; :}; // "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"

unary_op   ::= plus_op:p {: RESULT = "+"; :} 
              | minus_op:m {: RESULT = "-"; :}  
              | not_op:n {: RESULT = "!"; :}  
              | pow_op:p {: RESULT = "^"; :}  
              | star_op:s {: RESULT = "*"; :}  
              | amp_op:a {: RESULT = "&"; :} ; // "+" | "-" | "!" | "^" | "*" | "&" | "<-"

// ############################################### STATEMENT RULES #######################################################

Statement ::=
               Declaration 
               | SimpleStmt 
               | Func_call 
               | ReturnStmt 
               | BreakStmt 
               | ContinueStmt 
               | GotoStmt 
               | LabeledStmt 
               | Block 
               | IfStmt 
               | SwitchStmt
               | LabeledForStmt 
               // | ford {::} WhileStmt
               | ForStmt; 
               // | Func_call_ass;
            /*   | //| LabeledStmt | FallthroughStmt |
                error {: System.out.println("ERROR : Error Recovery production"); :};
*/
// Func_call_ass ::= IdentifierList equal Func_call;
SimpleStmt ::= Expression:e SimpleStmt_unnecessary_1:s1 
              {:
                  if(s1.get("List1")!=null)
                  {
                      LinkedList<GoExpr> e1= (LinkedList<GoExpr>)(s1.get("List1"));
                      LinkedList<GoExpr> e2= (LinkedList<GoExpr>)(s1.get("List2"));
                      e1.addFirst(e);
                      if(e1.size()!=e2.size())
                      {
                        System.out.println("ERROR: assignment count mismatch: "+e1.size()+" = "+e2.size());
                        // return;
                        // exit(0);
                      }
                      else
                      {
                        for(int i=0;i<e1.size();++i)
                        {
                        /*  Tac left =new Tac();
                          // Tac new_entry = new Tac();
                          // Tac right =new Tac();
                          String val_to_store = quad_array.get(e2.get(i).index).res;

                          String left_id = e1.get(i).get_identifier();
                            System.out.println("*************+++*"+left_id);

                          if(left_id.contains("["))
                          {
                            //Array Here
                            String temp = (left_id.split("\\["))[1];
                            left_id = (left_id.split("\\["))[0];
                            int inside_expr_index = Integer.parseInt((temp.split("\\]"))[0]);
                            SymbolTableEntry s = top.get(left_id);
                            
                           
                            left.res = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(inside_expr_index).res +">";
                            left.op1= val_to_store;
                            left.opr="=";
                            // new_entry.res = 
                          }
                          else
                          { 
                            System.out.println("**************"+left_id);
                            SymbolTableEntry s = top.get(left_id);
                            left.res = "Mem<"+ s.offset+">";
                            left.op1= val_to_store;
                            left.opr="=";
                             
                            //normal variable here

                          }
                          quad_array.add(left);*/
                          // SymbolTableEntry s = top.get();
                          // quad_array.add(left);
                          // Tac new_entry = new Tac();
                          // new_entry.opr="=";
                          // System.out.println("***************");
                          Tac new_entry2 = new Tac();
                          if(e1.get(i).unaryExpr.obj instanceof GoPrimaryExpr )
                          {
                            //for a[i]
                            if(((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj2!=null)
                            {
                              if(((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj2 instanceof GoIndex)
                              {
                              
                                int index= ((GoIndex)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj2).expr.index;

                                String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                SymbolTableEntry s = top.get(id);

                                String dataType_from_e1 = s.parsedDataType;
                                String dataType_from_e2 = e2.get(i).get_type(); 

                                String id_e2 = e2.get(i).get_identifier(); 

                                SymbolTableEntry sym = top.getQuiet(dataType_from_e2);
                                if ( sym != null )  // dataType_from_e2 is identifier
                                {
                                  dataType_from_e2 = sym.parsedDataType;
                                  // System.out.println("dataType_from_e2 changed to "+dataType_from_e2);
                                }
                              
                                dataType_from_e2 = get_type_from_symboltable(dataType_from_e2);


                                if ( dataType_from_e1.equals(dataType_from_e2) == false )
                                {
                                    if ( id_e2 != null )
                                      System.out.println("ERROR: cannot use "+id_e2+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 6");
                                    else
                                      System.out.println("ERROR: cannot use "+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 7");
                                }
                                else
                                {
                                  // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                                }

                                // new_entry2.res = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                new_entry2.op1 =quad_array.get(e2.get(i).index).res;
                                new_entry2.opr= "=" ;
                                // quad_array.add(new_entry);
                                quad_array.add(new_entry2);
                              }
                              else
                              {
                                System.out.println("ERROR : Illegal increment Operation ");

                              }

                            } 
                            else 
                            {
                              if( ((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1 instanceof GoOperand )
                              {
                                if(((GoOperand)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                {
                                  String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(e1.get(i).unaryExpr.obj)).obj1).obj).typeName;
                                  SymbolTableEntry s = top.get(id);
                                  // new_entry.op1 = "Mem<"+ s.offset +">";
                                  // new_entry.res = next_temp();
                                  
                                  String dataType_from_e1 = s.parsedDataType;
                                  String dataType_from_e2 = e2.get(i).get_type(); 



                                  String id_e2 = e2.get(i).get_identifier();
                                  SymbolTableEntry sym = top.getQuiet(dataType_from_e2);
                                  if ( sym != null )  // dataType_from_e2 is identifier
                                  {
                                    dataType_from_e2 = sym.parsedDataType;
                                    // System.out.println("dataType_from_e2 changed to "+dataType_from_e2);
                                  } 

                                  dataType_from_e2 = get_type_from_symboltable(dataType_from_e2);

                                  // System.out.println("456456455776 "+dataType_from_e2);
                                  if ( dataType_from_e1.equals(dataType_from_e2) == false )
                                  {
                                      if ( id_e2 != null )
                                        System.out.println("ERROR: cannot use "+id_e2+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 8");
                                      else
                                        System.out.println("ERROR: cannot use "+"(type "+dataType_from_e2+") as type "+dataType_from_e1+" in assignment 9");
                                  }
                                  else
                                  {
                                    // System.out.println("CORRECT: cannot use "+expList.get(i).get_identifier()+"(type "+dataType_from_exp+") as type "+dataType_from_vu+" in assignment");
                                  }


                                  // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                  // new_entry2.res = "Mem<"+ s.offset +">";
                                  new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                                  new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                  new_entry2.opr= "=" ;
                                  // quad_array.add(new_entry);
                                  quad_array.add(new_entry2);
                                }
                                else
                                {
                                    System.out.println("ERROR : rvalue can't be assigned to");
                                }
                              }
                              else
                                System.out.println("ERROR : ILLEGAL  OPERATION ");
                            }
                          }
                          else
                          {
                              System.out.println("ERROR : ILLEGAL  OPERATION 1");

                          }
                        }
                      }
                      //TODO  3 address code
                      /*for (int i =0; i<e1.size(); ++i ) 
                      {
                          // e1.get(i).gen();
                          System.out.println(s1.get("assign_op"));
                          // e2.get(i).gen();
                      }*/
                  }
                  else if(s1.get("inc_dec_op")!=null)
                  {
                      // e.gen();
                      // System.out.println(s1.get("inc_dec_op"));
                      Tac new_entry = new Tac();
                      Tac new_entry2 = new Tac();
                      String inc_or_dec = "";
                      if(s1.get("inc_dec_op")=="++")
                      {
                        new_entry.opr = "+";
                        inc_or_dec = "++";
                      }    
                      else
                      {
                        new_entry.opr = "-";
                        inc_or_dec = "--";
                      }
                        
                      new_entry.op2="1";
                      if(e.unaryExpr.obj instanceof GoPrimaryExpr )
                      {
                        //for a[i]
                        if(((GoPrimaryExpr)(e.unaryExpr.obj)).obj2!=null)
                        {
                          if(((GoPrimaryExpr)(e.unaryExpr.obj)).obj2 instanceof GoIndex)
                          {
                          
                            int index= ((GoIndex)((GoPrimaryExpr)(e.unaryExpr.obj)).obj2).expr.index;

                            String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(e.unaryExpr.obj)).obj1).obj1).obj).typeName;
                            SymbolTableEntry s = top.get(id);

                            // now this id should be of numeric type

                            if ( GoConstants.checkIfNumeric(s.parsedDataType) == false )
                            {
                              System.out.println("ERROR: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                            }
                            else
                            {
                              //System.out.println("CORRECT: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                            }


                            // new_entry.op1 = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry.op1 = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry.res = next_temp(s.parsedDataType);
                            new_entry.opr= "=";/***/

                            // new_entry2.res = "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry2.res = "#"+id+"#";// "Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                            new_entry2.op1 = new_entry.res;
                            new_entry2.opr= "=" ;
                            quad_array.add(new_entry);
                            quad_array.add(new_entry2);
                          }
                          else
                          {
                            System.out.println("ERROR : Illegal increment Operation ");

                          }

                        } 
                        else 
                        {
                          if( ((GoPrimaryExpr)(e.unaryExpr.obj)).obj1 instanceof GoOperand )
                          {
                            //handled for i++
                            if(((GoOperand)((GoPrimaryExpr)(e.unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                            {
                              String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(e.unaryExpr.obj)).obj1).obj).typeName;
                              SymbolTableEntry s = top.get(id);

                              if ( GoConstants.checkIfNumeric(s.parsedDataType) == false )
                              {
                                System.out.println("ERROR: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                              }
                              else
                              {
                                //System.out.println("CORRECT: invalid operation: "+inc_or_dec+" (non-numeric type "+s.parsedDataType+" )");
                              }

                              // new_entry.op1 = "Mem<"+ s.offset +">";
                              new_entry.op1 = "#"+id+"#";//"Mem<"+ s.offset +">";
                              new_entry.res = next_temp(s.parsedDataType);
                              new_entry.opr= "=";/***/
                              // new_entry2.res = "Mem<"+ s.offset +">";
                              new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                              new_entry2.op1 = new_entry.res;
                              new_entry2.opr= "=" ;
                              quad_array.add(new_entry);
                              quad_array.add(new_entry2);
                            }
                            else
                            {
                                // System.out.println("ERROR : ILLEGAL INCREEMENT OPERATION 2 ");
                            }
                          }
                          // else
                            // System.out.println("ERROR : ILLEGAL INCREEMENT OPERATION ");
                        }
                      }
                      // new_entry.res = "Mem<"+  +">" ;

                      // quad_array.get(e.index.res;
                  }
                   else if(s1.get("func_ass")!=null)
                  {
                      String[] allowed_expected_types = new String[]{"bool","byte","complex64","complex128","float32","float64","int","int8","int16","int32","int64","rune","string","uint","uint8","uint16","uint32","uint64","uintpt"};
                      // System.out.println("GOOD NEWs:  FUnction call assginment working");
                      LinkedList<GoExpr> expr = (LinkedList<GoExpr>)s1.get("func_ass");
                      expr.addFirst(e);
                      String func_name = "_"+((GoFunc_call)(s1.get("func_name"))).typeName.typeName;
                      SymbolTableEntry func_entry = top.get(func_name);
                      if(func_entry !=null )
                      {
                        GoSignature func_sig = (GoSignature)(func_entry.dataType);
                        if(func_sig.obj instanceof LinkedList)//multiple return types
                        {
                          int k=0;
                          LinkedList<GoParameterDecl> return_parameters = (LinkedList<GoParameterDecl>)(func_sig.obj);
                          if(return_parameters.size()==0)
                            System.out.println("ERROR: Can't extract from void function");
                          else
                          {
                            for(int i=0;i<return_parameters.size();++i)
                            {
                              GoParameterDecl params= return_parameters.get(i);
                              if(params.identifierList!=null)
                              {
                                for(int j=0;j<params.identifierList.size();++j)
                                {
                                  if(k==expr.size())
                                  {
                                    System.out.println("ERROR: Too many variables expected from functions");
                                    break;
                                  }
                                  SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);

                                  String expr_type = expr.get(k).get_type();
                                  if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                                    expr_type = top.get(expr_type).parsedDataType;
                                  if(!expr_type.equals(s100.parsedDataType))
                                  {
                                   System.out.println("expected : "+expr_type +" Found : "+s100.parsedDataType);
                                   System.out.println("ERROR: Type Mismatch in return_type");
                                  }
                                  
                                  //3AC for pulling out from stack
                                  Tac new_entry2 =new Tac();
                                  if(expr.get(k).unaryExpr.obj instanceof GoPrimaryExpr )
                                  {
                                    //for a[i]
                                    if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2!=null)
                                    {
                                      if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2 instanceof GoIndex)
                                      {
                                      
                                        int index= ((GoIndex)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2).expr.index;

                                        String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                        SymbolTableEntry s = top.get(id);
                                     
                                        new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                        new_entry2.op1 ="<get_from_stack>";
                                        new_entry2.opr= "=" ;
                                        // quad_array.add(new_entry);
                                        quad_array.add(new_entry2);
                                      }
                                      else
                                      {
                                        // System.out.println("ERROR : UNHANDLED ILLEGAL INCREEMENT OPERATION  ");

                                      }

                                    } 
                                    else 
                                    {
                                      if( ((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1 instanceof GoOperand )
                                      {
                                        if(((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                        {
                                          String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj).typeName;
                                          SymbolTableEntry s = top.get(id);
                                          // new_entry.op1 = "Mem<"+ s.offset +">";
                                          // new_entry.res = next_temp();
                                          
                                          // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                          new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                                          new_entry2.op1 ="<get_from_stack>";
                                          // new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                          new_entry2.opr= "=" ;
                                          // quad_array.add(new_entry);
                                          quad_array.add(new_entry2);
                                        }
                                        else
                                        {
                                            // System.out.println("ERROR : ILLEGAL  OPERATION 2 ");
                                        }
                                      }
                                      // else
                                        // System.out.println("ERROR : ILLEGAL  OPERATION ");
                                    }
                                  }
                                  else
                                  {
                                    // System.out.println("ERROR : ILLEGAL  OPERATION 1");
                                  } 
                                  k++;
                                }

                              }
                              else
                              {
                                if(k==expr.size())
                                {
                                  System.out.println("ERROR: Too many variables expected from functions");
                                  break;
                                }
                                SymbolTableEntry s100 =new SymbolTableEntry(params.type.obj,false,0);
                                String expr_type = expr.get(k).get_type();
                                if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                                  expr_type = top.get(expr_type).parsedDataType;
                                if(!expr_type.equals(s100.parsedDataType))
                                {
                                 System.out.println("expected :"+ expr_type +" Found : "+s100.parsedDataType);
                                 System.out.println("ERROR: Type Mismatch in return_type");
                                }
                               
                                Tac new_entry2 =new Tac();
                                if(expr.get(k).unaryExpr.obj instanceof GoPrimaryExpr )
                                {
                                  //for a[i]
                                  if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2!=null)
                                  {
                                    if(((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2 instanceof GoIndex)
                                    {
                                    
                                      int index= ((GoIndex)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj2).expr.index;

                                      String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                      SymbolTableEntry s = top.get(id);
                                   
                                      new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                      new_entry2.op1 ="<get_from_stack>";
                                      new_entry2.opr= "=" ;
                                      // quad_array.add(new_entry);
                                      quad_array.add(new_entry2);
                                    }
                                    else
                                    {
                                      // System.out.println("ERROR : UNHANDLED ILLEGAL INCREEMENT OPERATION  ");

                                    }

                                  } 
                                  else 
                                  {
                                    if( ((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1 instanceof GoOperand )
                                    {
                                      if(((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                      {
                                        String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(expr.get(k).unaryExpr.obj)).obj1).obj).typeName;
                                        SymbolTableEntry s = top.get(id);
                                        // new_entry.op1 = "Mem<"+ s.offset +">";
                                        // new_entry.res = next_temp();
                                        
                                        // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                        new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                                        new_entry2.op1 ="<get_from_stack>";
                                        // new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                        new_entry2.opr= "=" ;
                                        // quad_array.add(new_entry);
                                        quad_array.add(new_entry2);
                                      }
                                      else
                                      {
                                          // System.out.println("ERROR : ILLEGAL  OPERATION 2 ");
                                      }
                                    }
                                    // else
                                      // System.out.println("ERROR : ILLEGAL  OPERATION ");
                                  }
                                }
                                else
                                {
                                  // System.out.println("ERROR : ILLEGAL  OPERATION 1");
                                }
                                k++;

                              }
                            }
                          }
                        }
                        else if(func_sig.obj !=null && func_sig.obj instanceof GoType)//single return type
                        {
                           GoType params= (GoType)func_sig.obj;
                           SymbolTableEntry s100 =new SymbolTableEntry(params.obj,false,0);

                            if(expr.size()>1)
                            {
                              System.out.println("ERROR: Too much expected from function");
                            }
                            else
                            {
                              
                              String expr_type = expr.get(0).get_type();
                              if(!Arrays.asList(allowed_expected_types).contains(expr_type))//-->This is for variables
                                expr_type = top.get(expr_type).parsedDataType;
                              if(!expr_type.equals(s100.parsedDataType))
                              {
                               System.out.println("expected :"+ expr_type +" Found : "+s100.parsedDataType);
                               System.out.println("ERROR: Type Mismatch in Func_ass");
                              }
                              else
                              {

                                Tac new_entry2 =new Tac();
                                if(expr.get(0).unaryExpr.obj instanceof GoPrimaryExpr )
                                {
                                  //for a[i]
                                  if(((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj2!=null)
                                  {
                                    if(((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj2 instanceof GoIndex)
                                    {
                                    
                                      int index= ((GoIndex)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj2).expr.index;

                                      String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1).obj1).obj).typeName;
                                      SymbolTableEntry s = top.get(id);
                                   
                                      new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset+"+"+s.get_default_size()+"*"+quad_array.get(index).res +">";
                                      new_entry2.op1 ="<get_from_stack>";
                                      new_entry2.opr= "=" ;
                                      // quad_array.add(new_entry);
                                      quad_array.add(new_entry2);
                                    }
                                    else
                                    {
                                      // System.out.println("ERROR : UNHANDLED ILLEGAL INCREEMENT OPERATION  ");

                                    }

                                  } 
                                  else 
                                  {
                                    if( ((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1 instanceof GoOperand )
                                    {
                                      if(((GoOperand)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1).obj instanceof GoTypeName)
                                      {
                                        String id =  ((GoTypeName)((GoOperand)((GoPrimaryExpr)(expr.get(0).unaryExpr.obj)).obj1).obj).typeName;
                                        SymbolTableEntry s = top.get(id);
                                        // new_entry.op1 = "Mem<"+ s.offset +">";
                                        // new_entry.res = next_temp();
                                        
                                        // System.out.println("$$$$$$$ offset:" + s.offset+" id : "+id );
                                        new_entry2.res = "#"+id+"#";//"Mem<"+ s.offset +">";
                                        new_entry2.op1 ="<get_from_stack>";
                                        // new_entry2.op1 = quad_array.get((e2.get(i)).index).res;
                                        new_entry2.opr= "=" ;
                                        // quad_array.add(new_entry);
                                        quad_array.add(new_entry2);
                                      }
                                      else
                                      {
                                          // System.out.println("ERROR : ILLEGAL  OPERATION 2 ");
                                      }
                                    }
                                    // else
                                      // System.out.println("ERROR : ILLEGAL  OPERATION ");
                                  }
                                }
                                else
                                {
                                  // System.out.println("ERROR : ILLEGAL  OPERATION 1");
                                }

                              }
                            }
                            
                        }
                        else
                        {
                          //TODO
                          System.out.println("ERROR: Can't assign to Void Function");
                        }

                      }
                      else
                      {
                        System.out.println("ERROR: Function "+func_name +" not defined");
                      }
                  }
                  else
                  {
                      // System.out.println("ERROR:  SimpleStmt");
                  } 
                  
              :}
              | ;
SimpleStmt_unnecessary_1 ::=  ExpressionList_unnecessary_1:e1 assign_op:au ExpressionList:e2 
                              {:
                                  Map a1 = new HashMap(); 
                                  a1.put("List1", e1); 
                                  a1.put("List2", e2);
                                  a1.put("assign_op",au);
                                  RESULT = a1;
                              :}
                              | IncDecStmt_unnecessary_1 : e1
                              {:
                                  Map a1 = new HashMap(); 
                                  a1.put("inc_dec_op", e1); 
                                  RESULT = a1;
                              :}
                               | ExpressionList_unnecessary_1:e1 assign_op:au Func_call:fn
                              {:
                                  Map a1 = new HashMap(); 
                                  a1.put("func_ass", e1); 
                                  a1.put("func_name",fn);
                                  RESULT = a1;
                              :}
                              | ;
IncDecStmt_unnecessary_1 ::= inc_op {: RESULT = "++";:} | dec_op {: RESULT = "--";:};



assign_op ::= assign_op_unnecessary_1:au equal {: RESULT = au+"=";:};
assign_op_unnecessary_1 ::= add_op:ap {: RESULT = ap;:} | mul_op:ml {: RESULT = ml;:} | ;

Cheez ::= ifd Expression:e
             {:
                if(top!=null) 
                {
                  top = new Env(top,next_env_name(0)); 
                  // System.out.println("NEW TABLE IN If"); 
                }

                String l = next_label();  // used for else if
                String afterIf = next_label();  // after if block ends
                String index_res = quad_array.get( e.index ).res;
                Tac new_entry = new Tac();
                new_entry.op1 = "iffalse " + index_res;
                new_entry.opr = "goto";
                // new_entry.op2 = l;
                new_entry.res = l;
                quad_array.add(new_entry);

                Tac new_entry2 = new Tac();
                new_entry2.res=next_label()+":";
                new_entry2.opr=top.get_name();
                quad_array.add(new_entry2);

                Map a1 = new HashMap(); 
                a1.put("Expr", e); 
                a1.put("Label", l);   // l is for else or else if
                a1.put("AfterIf", afterIf);
                RESULT = a1;

                // RESULT = e;
            :}
             open_curly_brac StatementList close_curly_brac 
             {: 
                // print_sym_table();
                if(top.get_prev()!=null)
                  top = top.get_prev(); 
            :};

Cheez2 ::= ifd SimpleStmt:s semicolon Expression:e
             {:
                if(top!=null) 
                {
                  top = new Env(top,next_env_name(0)); 
                  // System.out.println("NEW TABLE IN If"); 
                }

                String l = next_label();  // used for else if
                String afterIf = next_label();  // after if block ends
                String index_res = quad_array.get( e.index ).res;
                Tac new_entry = new Tac();
                new_entry.op1 = "iffalse " + index_res;
                new_entry.opr = "goto";
                // new_entry.op2 = l;
                new_entry.res = l;
                quad_array.add(new_entry);

                Tac new_entry2 = new Tac();
                new_entry2.res=next_label()+":";
                new_entry2.opr=top.get_name();
                quad_array.add(new_entry2);
                Map a1 = new HashMap(); 

                a1.put("Expr", e); 
                a1.put("Label", l);   // l is for else or else if
                a1.put("AfterIf", afterIf);
                RESULT = a1;

                // RESULT = e;
            :}
             open_curly_brac StatementList close_curly_brac
             {: 
                // print_sym_table();
                if(top.get_prev()!=null)
                  top = top.get_prev(); 
            :}
             ;



/*Cheez ::= ifd UnaryExpr:ux
                {:
                  RESULT = new GoExpr(ux,ux.index);
                :}
                | ifd Expression:ex or_op:bo UnaryExpr:ux 
                {:
                    // int expr_index = ;
                    Tac expr = quad_array.get(ex.index);
                    Tac unexpr = quad_array.get(ux.index);
                    Tac new_entry = new Tac();
                    new_entry.res = next_temp()+"";
                    new_entry.opr = "||";
                    new_entry.op1= expr.res;
                    new_entry.op2= unexpr.res;
                    quad_array.add(new_entry);
                    // print_qaud_array();
                 RESULT = new GoExpr(ex,ux,quad_array.size()-1);

                :};*/

IfStmt ::=  Cheez2:c elsed 
            {: 

              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);


              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
            :} 
            IfStmt:is 
            {:
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              
              quad_array.add(new_entry);  
              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,is,true);
            :}

            | Cheez2:c elsed 
            {: 
              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);

               
            :}
            open_curly_brac 
            {: if(top!=null) 
                {
                  top = new Env(top,next_env_name(0));

                  Tac new_entry = new Tac();
                  new_entry.res = c.get("Label")+":";
                  new_entry.opr = top.get_name();

                  quad_array.add(new_entry);
                } 
            :}
            StatementList close_curly_brac 
            {: 
              // print_sym_table();
              if(top.get_prev()!=null)
                top = top.get_prev(); 
             
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry);
              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,true);
            :}
           
            | Cheez2:c 
            {:  // no need to create redundant label AfterIf
              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
              GoExpr e = (GoExpr)c.get("Expr"); RESULT = new GoIfStmt(e); 
            :}

            | Cheez:c elsed 
            {: 

              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);


              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
            :} 
            IfStmt:is 
            {:
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry);  
              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,is,true);
            :}
           
            | Cheez:c elsed 
            {: 
              Tac new_entry2 = new Tac();
              new_entry2.res = (String)c.get("AfterIf");
              new_entry2.opr = "goto";
              quad_array.add(new_entry2);

            
            :}
            open_curly_brac 
            {: if(top!=null) 
                {
                  top = new Env(top,next_env_name(0));

                  Tac new_entry = new Tac();
                  new_entry.res = c.get("Label")+":";
                  new_entry.opr = top.get_name();

                  quad_array.add(new_entry);
                } 
            :}
            StatementList close_curly_brac 
            {: 
              // print_sym_table();
              if(top.get_prev()!=null)
                top = top.get_prev(); 
              
              Tac new_entry = new Tac();
              new_entry.res = c.get("AfterIf")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry);

              GoExpr e = (GoExpr)c.get("Expr"); 
              RESULT = new GoIfStmt(e,true);
            :}
           
            | Cheez:c 
            {:  // no need to create redundant label AfterIf
              Tac new_entry = new Tac();
              new_entry.res = c.get("Label")+":";
              new_entry.opr = top.get_name();
              quad_array.add(new_entry); 
              GoExpr e = (GoExpr)c.get("Expr"); RESULT = new GoIfStmt(e); 
            :};


          //  | ifd Expression:e Block:b elsed IfStmt:is {: RESULT = new GoIfStmt(e,is,true);:}
          //  | ifd Expression:e Block:b1 elsed Block:b2 {: RESULT = new GoIfStmt(e,true);:}


          //    | ifd Expression:e
          //    {:
          //       if(top!=null && top.ifinfunc==false) 
          //       {
          //         top = new Env(top); 
          //         System.out.println("NEW TABLE"); 
          //       }
          //       String l = next_label();
          //       String index_res = quad_array.get( e.index ).res;
          //       Tac new_entry = new Tac();
          //       new_entry.op1 = "if " + index_res;
          //       new_entry.opr = "goto ";
          //       // new_entry.op2 = l;
          //       new_entry.res = l;
          //       quad_array.add(new_entry);
          //       // RESULT = e;
          //   :}
          //    open_curly_brac 
          // StatementList close_curly_brac {: RESULT = new GoIfStmt(e);:};

             //Block:b {: RESULT = new GoIfStmt(e);:};

SwitchStmt ::= ExprSwitchStmt;

ExprSwitchStmt ::= switchd SimpleStmt semicolon Expression open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac
        |  switchd Expression open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac
        |  switchd open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac
        |  switchd SimpleStmt semicolon open_curly_brac ExprSwitchStmt_unnecessary_3 close_curly_brac;

ExprSwitchStmt_unnecessary_3 ::= ExprSwitchStmt_unnecessary_3 ExprCaseClause | ;
ExprCaseClause ::= cased ExpressionList colon StatementList | defaultd colon StatementList ;

// WhileStmt ::= Expression open_curly_brac StatementList close_curly_brac;


ForStmt ::= ford
            {: 
                top = new Env(top,next_env_name(0)); 
                // System.out.println("NEW TABLE IN For");

                String fraudForForClauseSimpleStmt = next_label();
                
                Tac new_entry2 = new Tac();
                new_entry2.res = fraudForForClauseSimpleStmt+":";
                new_entry2.opr = top.get_name();

                quad_array.add(new_entry2);


                String condCheck = next_label();
                
                Tac new_entry = new Tac();
                new_entry.res = condCheck+":";
                new_entry.opr = top.get_name();

                quad_array.add(new_entry);
                SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,condCheck);
                top.put("for<>", s);
                // f = condCheck;
                 
            :} 
            ForStmt_unnecessary_1:fu 
            {: 
              String outOfFor = (String)fu.get("outOfFor");
              String forBlock = (String)fu.get("forBlock"); 
              String update = (String)fu.get("update");
              

              SymbolTableEntry s = top.getQuiet("for<>");

              if ( forBlock != null ) // we are in for instead of while
              {
                Tac new_entry = new Tac();
                new_entry.res = forBlock+":";
                new_entry.opr = top.get_name();
                quad_array.add(new_entry);
                
                
                quad_array.remove( s.size); // removing whileStart since that is done in forClause
                
              }
              LinkedList<String> forLabels = new LinkedList<String>();

              if ( update == null ) // coming from a while loop
                update = s.parsedDataType;

              fu.put("forStart", s.parsedDataType);

              forLabels.add(s.parsedDataType);  // forLabels[0] = forStart ie condCheck
              forLabels.add(outOfFor);          // forLabel[1] =  outOfFor
              forLabels.add(update);            // forLabels[2] = update in case of for
              s.dataType = (LinkedList<String>)forLabels; // to help the labeled for statement
              top.update("for<>", s);

              SymbolTableEntry s2 = top.getFromParent("for<label>");

              if ( s2 != null )
              {
                String label = s2.parsedDataType; // this is the unique label for this for
                top.removeFromParent("for<label>"); // remove this entry from parent so that other fors of parent can use it

                SymbolTableEntry s3 = top.getFromParent(label);
                s3.dataType = (LinkedList<String>)forLabels;
                top.update(label, s3);
              }

            :} 
            open_curly_brac StatementList close_curly_brac
            {: 
                String update = (String)fu.get("update");
                if(update==null)
                  update = top.getQuiet("for<>").parsedDataType;
                
                Tac new_entry = new Tac();
                new_entry.res = update;
                new_entry.opr = "goto";
                quad_array.add(new_entry);
                
                if(top.get_prev()!=null)
                  top = top.get_prev(); 

                String outOfFor = (String)fu.get("outOfFor"); 
                Tac new_entry2 = new Tac();
                new_entry2.res = outOfFor+":";
                new_entry2.opr = top.get_name();
                quad_array.add(new_entry2);

                // print_sym_table();


                String forBlock = (String)fu.get("forBlock"); 
                String forStart = (String)fu.get("forStart");
                RESULT = new GoForStmt(forStart, forBlock, update, outOfFor); 
            :}
            
            |  ForStmt_unnecessary_2:fu
              open_curly_brac StatementList close_curly_brac
              {: 
                  String forStart = (String)fu.get("forStart");
                  Tac new_entry = new Tac();
                  new_entry.res = forStart;
                  new_entry.opr = "goto";
                  quad_array.add(new_entry);

                  // print_sym_table();
                  if(top.get_prev()!=null)
                    top = top.get_prev();

                  String outOfFor = (String)fu.get("outOfFor"); 
                  Tac new_entry2 = new Tac();
                  new_entry2.res = outOfFor+":";
                  new_entry2.opr = top.get_name();
                  quad_array.add(new_entry2);



                  String forBlock = forStart;
                  String update = forStart;
                  RESULT = new GoForStmt(forStart, forBlock, update, outOfFor);  
              :};


ForStmt_unnecessary_2 ::= ford 
            {: 
                top = new Env(top,next_env_name(0)); 

                String forStart = next_label();
                Tac new_entry = new Tac();
                new_entry.res = forStart+":";
                new_entry.opr = top.get_name();
                quad_array.add(new_entry);

                // System.out.println("NEW TABLE IN For");
                

                String outOfFor = next_label(); // we are generating out of for before hand so that statements inside the infinite loop can access  it to break out


                SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1, outOfFor);
                top.put("for<>", s);

                SymbolTableEntry s2 = top.getQuiet("for<>");
                LinkedList<String> forLabels = new LinkedList<String>();
                forLabels.add(forStart);  // s.parsedDataType
                forLabels.add(outOfFor);
                forLabels.add(forStart);  // the update statement is same as forStart
                s2.dataType = (LinkedList<String>)forLabels;

                SymbolTableEntry s4 = top.getFromParent("for<label>");
                if ( s4 != null ) // if we do have a label for for
                {
                  String label = s4.parsedDataType; // this is the unique label for this for
                  top.removeFromParent("for<label>"); // remove this entry from parent so that other fors of parent can use it

                  SymbolTableEntry s3 = top.getFromParent(label);
                  s3.dataType = (LinkedList<String>)forLabels;
                  top.update(label, s3);
                }

                Map cm = new HashMap();
                cm.put("forStart", forStart);
                cm.put("outOfFor", outOfFor);
                RESULT = cm; 

            :};


ForStmt_unnecessary_1 ::= 
                          Expression:e
                          {:
                           
                              String outOfFor = next_label();
                              
                              String index_res = quad_array.get( e.index ).res;
                              Tac new_entry2 = new Tac();
                              new_entry2.op1 = "iffalse " + index_res;
                              new_entry2.opr = "goto";
                              // new_entry.op2 = l;
                              new_entry2.res = outOfFor;
                              quad_array.add(new_entry2);

                              // Generate a forStart here also as we require is for LeaderBlock
                              String forStart = next_label();
                                Tac new_entry = new Tac();
                                new_entry.res = forStart+":";
                                new_entry.opr = top.get_name();
                                quad_array.add(new_entry);


                              Map cm = new HashMap();
                              cm.put("outOfFor", outOfFor);
                              // cm.put("update", condCheck);

                              RESULT = cm;
                          :}

                          | 
                            ForClause:fc 
                            {:
                              RESULT = fc;
                            :};// | RangeClause;




ForClause ::= ForClause_Unneccesary:fu
              Condition_unnecessary_1:cm semicolon 
              {:
                  GoExpr e = (GoExpr)cm.get("Expr");
                  String outOfFor = next_label();
                  if ( e != null )  // condition exists
                  {  
                    String index_res = quad_array.get( e.index ).res;
                    Tac new_entry = new Tac();
                    new_entry.op1 = "iffalse " + index_res;
                    new_entry.opr = "goto";
                    // new_entry.op2 = l;
                    new_entry.res = outOfFor;
                    quad_array.add(new_entry);

                 }

                  String forBlock = next_label();

                  Tac new_entry2 = new Tac();
                  new_entry2.res = forBlock;
                  new_entry2.opr = "goto";
                  quad_array.add(new_entry2);

                  String update = next_label();
                  Tac new_entry3 = new Tac();
                  new_entry3.res = update+":";
                  new_entry3.opr = top.get_name();
                  quad_array.add(new_entry3);

                  cm.put("outOfFor", outOfFor);
                  cm.put("update", update);
                  cm.put("forBlock", forBlock);
              :}
              SimpleStmt
              {:
                  String condCheck = fu;
                  Tac new_entry2 = new Tac();
                  new_entry2.res = condCheck;
                  new_entry2.opr = "goto";
                  quad_array.add(new_entry2);

                  RESULT = cm;
              :};


ForClause_Unneccesary ::= SimpleStmt semicolon 
                          {:
                              String condCheck = next_label();
                              Tac new_entry = new Tac();
                              new_entry.res = condCheck+":";
                              new_entry.opr = top.get_name();

                              quad_array.add(new_entry);
                              RESULT = condCheck;
                          :};

Condition_unnecessary_1 ::= Expression:e {: Map cm = new HashMap(); cm.put("Expr", e); RESULT = cm; :}
                            | {: Map cm = new HashMap(); RESULT = cm; :} ;


ReturnStmt ::= returnd ExpressionList:el
              {:
                if(top.parent == null)
                {
                  System.out.println("ERROR : Return statement written in a global scope");
                }
                if( top.get("return[0]") ==null )
                  System.out.println("ERROR : VOID RETURN TYPE ");
                else
                {
                    SymbolTableEntry s = new SymbolTableEntry();
                    top.put("@return@",s);//for checking return statement presence
                    //TODO-DONE 3AC for return statement
                    //Store the variables expecting result and then store the values of the current variable in the parent's symmbol table and then jump to lasr statement
                    String[] allowed_expected_types =  new String[] {"int","imaginary","float","rune","string"};
                    for(int i=0;i<el.size();++i)
                    {
                      if( top.get("return["+i+"]") !=null )
                      {

                        String expected_type=top.get("return["+i+"]").parsedDataType;//this will be fixed and more confident type
                        String return_type = el.get(i).get_type(); //this can be loose as sand
                        if(!Arrays.asList(allowed_expected_types).contains(return_type))//-->This is for variables
                           return_type = top.get(return_type).parsedDataType;
                        
                        if( !expected_type.contains(return_type) )
                        { 
                          System.out.println("ERROR : Return Type Mismatch");
                          System.out.println("expected_type : "+expected_type+" return_type "+return_type);
                          // break;
                        }
                        else
                        {
                          Tac new_entry =new Tac();
                          new_entry.res = "push";
                          new_entry.op1 = quad_array.get(el.get(i).index).res;
                          quad_array.add(new_entry);
                        }
                      }
                      else
                      {
                        System.out.println("ERROR : too many return variables!");
                        break;
                      }
                    }
                    if(top.get("return["+el.size()+"]") !=null)
                        System.out.println("ERROR : too few return variables!");
                }

                // System.out.println(" RETURNED HERE "+el.get(0).get_type());

              :} 
              | returnd 
                {:
                  if(top.parent == null)
                  {
                    System.out.println("ERROR : Return statement written in a global scope");
                  }
                  SymbolTableEntry s = new SymbolTableEntry();
                  top.put("@return@",s); //for checking return statement presence
               :} ;




BreakStmt ::=  breakd identifier:i 
                {: 
                    if(top.getQuiet("for<>")==null)
                    {
                        System.out.println("ERROR: break is not in a loop");
                    }
                    else
                    {
                        SymbolTableEntry s = top.get(i);
                        if ( s == null )
                        {
                          System.out.println("ERROR: break label not defined: "+i);
                        }
                        else
                        {
                          // checking if that label is a label type or not
                          if ( s.parsedDataType == "for<label>" )
                          {
                            Tac new_entry = new Tac();
                            // if ( i != quad_array.get(s.size).res )
                            // {
                              // System.out.println("ERROR: CRRRRAP");
                            // }
                            new_entry.res = ((LinkedList<String>)s.dataType).get(1);// ((LinkedList<String>)s.dataType).get(1);  // 1 for outOfFor
                            new_entry.opr = "goto";
                            quad_array.add(new_entry);
                            // System.out.println("Breaking out of a block. Using identifier with a break"+i);

                            // now we need to create a new label for LeaderBlock
                            String label = next_label();
                            Tac new_entry2 = new Tac();
                            new_entry2.res = label+":";
                            new_entry2.opr = top.get_name();
                            quad_array.add(new_entry2);
                          }
                          else
                          {
                            System.out.println("ERROR: invalid break label "+i);
                          }
                          
                        } 
                    }
                 :}
               | breakd 
                {: 
                    if( top.getQuiet("for<>") == null )
                    {
                        System.out.println("ERROR: break is not in a loop");
                    }
                    else
                    {
                        String outOfFor = (String) ((LinkedList<String>)top.getQuiet("for<>").dataType).get(1); // 0 contains forStart
                        Tac new_entry = new Tac();
                        new_entry.res = outOfFor;
                        new_entry.opr = "goto";
                        quad_array.add(new_entry);
                        // System.out.println("Breaking out of For Loop");

                        // now we need to create a new label for LeaderBlock
                            String label = next_label();
                            Tac new_entry2 = new Tac();
                            new_entry2.res = label+":";
                            new_entry2.opr = top.get_name();
                            quad_array.add(new_entry2);
                    }
                :};// breakd Label |


Label ::= identifier:i colon 
                {: 
                    // System.out.println("New LabeledStmt is called with identifier :"+i);

                    String label =  i;
                    Tac new_entry = new Tac();
                    new_entry.res = label+":";
                    new_entry.opr = top.get_name();

                    quad_array.add(new_entry);

                    SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,"<label>");
                    top.put(label, s);
                 :};

LabeledStmt ::= Label Declaration 
               | Label SimpleStmt 
               | Label Func_call 
               | Label ReturnStmt 
               | Label BreakStmt 
               | Label ContinueStmt 
               | Label GotoStmt 
               | Label LabeledStmt 
               | Label Block 
               | Label IfStmt 
               | Label SwitchStmt
               | Label LabeledForStmt ;

LabeledForStmt ::= identifier:i colon 
                  {: 
                    // System.out.println("New LabeledForStmt is called with identifier :"+i);

                    String label =  i;
                    Tac new_entry = new Tac();
                    new_entry.res = label+":";
                    new_entry.opr = top.get_name();
                    
                    quad_array.add(new_entry);

                    SymbolTableEntry s = new SymbolTableEntry(quad_array.size()-1,"for<label>");
                    top.put(label, s);
                    SymbolTableEntry s2 = new SymbolTableEntry(quad_array.size()-1,label);
                    top.put("for<label>", s2);  // now will search it in forStmt to see if any label attached to it.
                    // Since each for can have atmost 1 label attached to it, we will find only one entry in its parent's symbol table entry.
                    // As soon as we use this entry, we will delete it so that other for's can have their labels in the parent's ST
                 :} 
                 ForStmt;


GotoStmt ::= gotod identifier:i 
              {: 
                  SymbolTableEntry s = top.getLabel(i);
                  if ( s == null )
                  {
                    System.out.println("ERROR: label "+i+" not defined"); 
                  }
                  else
                  {
                    // System.out.println("New GotoStmt is called with identifier :"+i); 
                    Tac new_entry = new Tac();
                    new_entry.res = i;
                    new_entry.opr = "goto";
                    quad_array.add(new_entry);         

                    // now we need to create a new label for LeaderBlock
                    String label = next_label();
                    Tac new_entry2 = new Tac();
                    new_entry2.res = label+":";
                    new_entry2.opr = top.get_name();
                    quad_array.add(new_entry2);

                  }
              :};




ContinueStmt ::= continued identifier:i 
                {: 
                  if( top.getQuiet("for<>") == null )
                  {
                      System.out.println("ERROR: continue is not in a loop");
                  }
                  else
                  {
                      SymbolTableEntry s = top.get(i);
                      if ( s == null )
                      {
                        System.out.println("ERROR: continue label not defined: "+i);
                      }
                      else
                      {
                        // checking if that label is a label type or not
                        if ( s.parsedDataType == "for<label>" )
                        {
                          Tac new_entry = new Tac();
                          // if ( i != quad_array.get(s.size).res )
                          // {
                            // System.out.println("ERROR: CRRRRAP");
                          // }
                          new_entry.res = ((LinkedList<String>)s.dataType).get(2);  // 2 for update
                          new_entry.opr = "goto";
                          quad_array.add(new_entry);
                          // System.out.println("Continuing to top of a block. Using identifier "+i);

                          // now we need to create a new label for LeaderBlock
                            String label = next_label();
                            Tac new_entry2 = new Tac();
                            new_entry2.res = label+":";
                            new_entry2.opr = top.get_name();
                            quad_array.add(new_entry2);


                        }
                        else
                        {
                          System.out.println("ERROR: invalid continue label "+i);
                        }
                        
                      } 
                  }
               :}
                | continued 
                {: 
                    if( top.getQuiet("for<>") == null )
                    {
                        System.out.println("ERROR: continue is not in a loop");
                    }
                    else
                    {
                        String forStartorUpdate = (String) ((LinkedList<String>)top.getQuiet("for<>").dataType).get(2); // 0 contains forStart
                        Tac new_entry = new Tac();
                        new_entry.res = forStartorUpdate;
                        new_entry.opr = "goto";
                        quad_array.add(new_entry);
                        // System.out.println("Continuing to top of For Loop.");

                        // now we need to create a new label for LeaderBlock
                          String label = next_label();
                          Tac new_entry2 = new Tac();
                          new_entry2.res = label+":";
                          new_entry2.opr = top.get_name();
                          quad_array.add(new_entry2);

                    }
                :}; // continued Label |



// ############################################### PACKAGES RULES #######################################################

SourceFile ::={: top =null; gen_registers(); /*Tac fraud = new Tac("2","+","1","1");
  quad_array.add(fraud);*/:} PackageClause semicolon  SourceFile_unnecessary_1 
  {: 
    top = new Env(top,next_env_name(0));
    Env.global_env = top;

    Tac new_entry = new Tac();
    new_entry.res = "GLOBAL:";
    new_entry.opr = top.get_name();
    quad_array.add(new_entry);
    // System.out.println("NEW GLOBAL TABLE");
  :}

   SourceFile_unnecessary_2
              {:
                    // System.out.println("Changing Tables");
                   // print_sym_table();
                   // print_qaud_array();
               next_step();

              :};
SourceFile_unnecessary_1 ::= SourceFile_unnecessary_1_dash;
SourceFile_unnecessary_1_dash ::= ImportDecl semicolon SourceFile_unnecessary_1_dash | ;
SourceFile_unnecessary_2 ::= SourceFile_unnecessary_2_dash;
SourceFile_unnecessary_2_dash ::= TopLevelDecl semicolon SourceFile_unnecessary_2_dash | ;
PackageClause ::= packaged identifier:i
                  {:
                      Tac new_entry = new Tac();
                          new_entry.res = "package";
                          new_entry.op1 = i;
                          quad_array.add(new_entry);
                  :};

ImportDecl ::= importd ImportDecl_unnecessary_2:il
              {:
                Tac new_entry;
                for ( int q = 0; q < il.size(); q++ )
                {
                  new_entry = new Tac();
                  new_entry.res = "import";
                  new_entry.op1 = il.get(q);
                  quad_array.add(new_entry);
                }
              :};

ImportDecl_unnecessary_1 ::= ImportDecl_unnecessary_1:il ImportSpec:i semicolon 
                              {:
                                  for ( int q = 0; q < i.size(); q++ )
                                  {
                                    il.add(i.get(q));
                                  }
                                  RESULT = il;
                              :}
                              | 
                              {:
                                LinkedList<String> a = new LinkedList<String>();
                                RESULT = a;
                              :};


ImportDecl_unnecessary_2 ::= ImportSpec:i {: RESULT = i; :} 
                            | open_brac ImportDecl_unnecessary_1:il close_brac {: RESULT = il; :};

ImportSpec ::= dot string_lit:sl 
              {: 
                LinkedList<String> a = new LinkedList<String>(); 
                a.add("."); a.add(sl); 
                RESULT = a; 
              :}
              | identifier:i string_lit:sl
              {: 
                LinkedList<String> a = new LinkedList<String>(); 
                a.add(i); a.add(sl); 
                RESULT = a; 
              :}
              |  string_lit:sl
              {: 
                LinkedList<String> a = new LinkedList<String>(); 
                // a.add(""); 
                a.add(sl); 
                RESULT = a; 
              :};

